{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Laborat\u00f3rios de Bioinform\u00e1tica (BIOINF1001)","text":"<p>P\u00e1gina de apoio \u00e0s aulas pr\u00e1ticas da UC de Laborat\u00f3rios de Bioinform\u00e1tica (BIOINF1001) da Faculdade de Ci\u00eancias da Universidade do Porto (Licenciatura em Bioinform\u00e1tica).</p>"},{"location":"#docentes","title":"Docentes","text":"<ul> <li>Miriam Santos: miriam.santos@fc.up.pt</li> <li>Pedro Ferreira: pgferreira@fc.up.pt</li> </ul>"},{"location":"#laboratorios","title":"Laborat\u00f3rios","text":"<ul> <li>Lab 21/02: Bases de dados de Sequ\u00eancias Biol\u00f3gicas </li> <li>Lab 28/02: Introdu\u00e7\u00e3o \u00e0 Linha de Comandos</li> <li>Lab 07/03: Introdu\u00e7\u00e3o ao Shell Scripting</li> <li>Lab 14/03: Semelhan\u00e7a de Sequ\u00eancias Biol\u00f3gicas</li> <li>Lab 21/03: Processamento B\u00e1sico de Sequ\u00eancias</li> <li>Lab 28/03: Workflows para Processamento de Sequ\u00eancias Biol\u00f3gicas</li> </ul>"},{"location":"#software","title":"Software","text":"<ul> <li>Git Bash: Instala uma shell <code>bash</code> no Windows (Nota: \u00e9 uma boa alternativa \u00e0 PowerShell ou \u00e0 Windows Command Prompt, na qual os comandos abordados nas aulas podem n\u00e3o funcionar diretamente).</li> </ul>"},{"location":"links/","title":"Links \u00dateis","text":""},{"location":"links/#informacoes-da-uc","title":"Informa\u00e7\u00f5es da UC","text":"<ul> <li>Moodle Laborat\u00f3rios de Bioinform\u00e1tica 24/25</li> <li>P\u00e1gina do Sigarra | Laborat\u00f3rios de Bioinform\u00e1tica (BIOINF1001) </li> </ul>"},{"location":"links/#materiais","title":"Materiais","text":""},{"location":"links/#tutoriais","title":"Tutoriais","text":"<ul> <li>UCI Davis: Introduction to the Command Line for Bioinformatics</li> <li>Software Carpentry: The Unix Shell</li> <li>Data Carpentry: Introduction to the Command Line for Genomics</li> <li>Berkeley Statistics: Bash Shell tutorial</li> </ul>"},{"location":"links/#livros","title":"Livros","text":"<ul> <li>Data Science at the Command Line</li> <li>A Primer for Computational Biology</li> <li>Bioinformatics Programming Using Python</li> </ul>"},{"location":"links/#cheatsheets-e-manuais","title":"Cheatsheets e Manuais","text":"<ul> <li>Unix CheatSheet (.pdf)</li> <li>Sed: A Stream Editor, 2024</li> <li>Bash Regex Matching</li> <li>grep, awk, and sed</li> </ul>"},{"location":"help/lista_comandos/","title":"Lista de comandos","text":"Comando Descri\u00e7\u00e3o Exemplo Explica\u00e7\u00e3o <code>ls</code> Lista os ficheiros e pastas na diretoria atual. <code>ls -l</code> Lista os ficheiros em formato detalhado. <code>cd</code> Muda para outra diretoria. <code>cd /home/user</code> Vai para a diretoria <code>/home/user</code>. <code>pwd</code> Mostra o caminho da diretoria atual. <code>pwd</code> Mostra o caminho completo da diretoria atual. <code>mkdir</code> Cria uma nova diretoria. <code>mkdir novos_docs</code> Cria a diretoria <code>novos_docs</code>. <code>rmdir</code> Remove uma diretoria vazia. <code>rmdir antigos_docs</code> Remove <code>antigos_docs</code>, se estiver vazio. <code>rm</code> Remove ficheiros ou pastas. <code>rm -r pasta</code> Remove a <code>pasta</code> e todo o seu conte\u00fado. <code>cp</code> Copia ficheiros ou pastas. <code>cp ficheiro.txt backup/</code> Copia <code>ficheiro.txt</code> para a pasta <code>backup/</code>. <code>mv</code> Move ou renomeia ficheiros e diretorias. <code>mv ficheiro.txt novo_nome.txt</code> Renomeia <code>ficheiro.txt</code> para <code>novo_nome.txt</code>. <code>find</code> Pesquisa ficheiros e diretorias no sistema. <code>find /home -name \"*.txt\"</code> Procura ficheiros <code>.txt</code> em <code>/home</code>. <code>grep</code> Pesquisa padr\u00f5es de texto dentro de ficheiros. <code>grep \"erro\" log.txt</code> Procura a palavra \"erro\" dentro de <code>log.txt</code>. <code>tar</code> Compacta ou extrai ficheiros. <code>tar -cvf backup.tar pasta/</code> Cria um ficheiro <code>backup.tar</code> com os ficheiros da <code>pasta/</code>. <code>zip</code> / <code>unzip</code> Compacta e descompacta ficheiros ZIP. <code>zip arquivo.zip documento.txt</code> Compacta <code>documento.txt</code> em <code>arquivo.zip</code>. <code>wget</code> Faz download de ficheiros da web. <code>wget http://site.com/ficheiro.zip</code> Baixa <code>ficheiro.zip</code> do site especificado. <code>curl</code> Transfer\u00eancia de dados via protocolos variados. <code>curl -O http://site.com/ficheiro.zip</code> Faz download de <code>ficheiro.zip</code> usando <code>curl</code>. <code>cat</code> Mostra o conte\u00fado de um ficheiro. <code>cat texto.txt</code> Exibe o conte\u00fado do ficheiro <code>texto.txt</code>. <code>less</code> Visualiza ficheiros p\u00e1gina a p\u00e1gina. <code>less texto.txt</code> Permite navegar pelo ficheiro <code>texto.txt</code>. <code>nano</code> Editor de texto simples no terminal. <code>nano texto.txt</code> Abre <code>texto.txt</code> para edi\u00e7\u00e3o no <code>nano</code>. <code>echo</code> Exibe mensagens no terminal. <code>echo \"Ol\u00e1, Mundo!\"</code> Mostra a mensagem <code>\"Ol\u00e1, Mundo!\"</code> no terminal. <code>exit</code> Sai da sess\u00e3o atual do terminal. <code>exit</code> Fecha o terminal ou termina a sess\u00e3o SSH. <code>wc</code> Conta linhas, palavras e caracteres em ficheiros. <code>wc -l ficheiro.txt</code> Conta o n\u00famero de linhas em <code>ficheiro.txt</code>. <code>head</code> Mostra as primeiras linhas de um ficheiro. <code>head -n 5 ficheiro.txt</code> Mostra as primeiras 5 linhas de <code>ficheiro.txt</code>. <code>tail</code> Mostra as \u00faltimas linhas de um ficheiro. <code>tail -n 5 ficheiro.txt</code> Mostra as \u00faltimas 5 linhas de <code>ficheiro.txt</code>. <code>touch</code> Cria um ficheiro vazio ou atualiza a data de modifica\u00e7\u00e3o. <code>touch novo.txt</code> Cria <code>novo.txt</code> se n\u00e3o existir ou atualiza sua data. <code>whoami</code> Mostra o utilizador atualmente logado. <code>whoami</code> Retorna o nome do utilizador. <code>date</code> Mostra a data e hora atuais. <code>date</code> Mostra a data e hora do sistema. <code>man</code> Mostra o manual de um comando. <code>man ls</code> Mostra o manual do comando <code>ls</code>. <code>basename</code> Extrai o nome do ficheiro de um caminho (path). <code>basename /home/user/documento.txt</code> Retorna <code>documento.txt</code>. <code>dirname</code> Extrai a pasta de um caminho. <code>dirname /home/user/documento.txt</code> Retorna <code>/home/user</code>. <code>uniq</code> Remove linhas duplicadas de um ficheiro. <code>sort lista.txt | uniq</code> Remove duplicados da lista ordenada. <code>cut</code> Extrai partes espec\u00edficas de linhas em ficheiros. <code>cut -d\",\" -f2 dados.csv</code> Mostra apenas as idades de um ficheiro <code>dados.csv</code> organizado como <code>Nome,Idade</code>. <code>tr</code> Substitui ou remove caracteres em texto. <code>echo \"teste\" | tr 'e' 'a'</code> Substitui <code>\"e\"</code> por <code>\"a\"</code> na palavra <code>\"teste\"</code> (tasta)."},{"location":"help/shell_scripting/","title":"Shell Scripting","text":""},{"location":"help/shell_scripting/#simbolos","title":"S\u00edmbolos","text":"S\u00edmbolo Descri\u00e7\u00e3o Exemplo Explica\u00e7\u00e3o $0 ... $9 Par\u00e2metros da linha de comandos <code>$1</code> Representa o primeiro argumento passado ao script $* Todos os par\u00e2metros da linha de comandos <code>echo \"$*\"</code> Exibe todos os argumentos como uma \u00fanica string $# N\u00famero de par\u00e2metros da linha de comandos <code>echo $#</code> Retorna a contagem dos argumentos passados $? C\u00f3digo de retorno (exit status) do \u00faltimo comando executado <code>ls /teste; echo $?</code> Mostra <code>0</code> se o comando for bem-sucedido ou um n\u00famero diferente se falhar \"...\" Protege uma string, mas reconhece <code>$</code>, <code>`</code>, <code>\\</code> e <code>!</code> como especiais <code>echo \"O usu\u00e1rio \u00e9 $USER\"</code> Expande vari\u00e1veis dentro da string '...' Protege uma string sem reconhecer caracteres especiais <code>echo 'O usu\u00e1rio \u00e9 $USER'</code> A string \u00e9 impressa exatamente como est\u00e1, sem expans\u00e3o `...` ou $(...) Executa comandos numa subshell <code>echo \"Hoje \u00e9 `date`\"</code> O comando dentro das backticks \u00e9 executado e substitu\u00eddo pelo resultado $((...)) Retorna o resultado de uma express\u00e3o aritm\u00e9tica <code>echo $((5 + 3))</code> Avalia a express\u00e3o e imprime <code>8</code>"},{"location":"help/shell_scripting/#testes-e-expressoes","title":"Testes e Express\u00f5es","text":"Comando Descri\u00e7\u00e3o Exemplo Explica\u00e7\u00e3o test express\u00e3o Testa uma express\u00e3o <code>test 5 -gt 3</code> Retorna verdadeiro (<code>0</code>) se 5 for maior que 3 Compara\u00e7\u00e3o num\u00e9rica <code>NUM1 OP NUM2</code> (OP: -lt, -gt, -le, -ge, -eq, -ne) <code>[ 10 -eq 10 ]</code> Compara dois n\u00fameros inteiros Compara\u00e7\u00e3o de strings <code>STR1 OP STR2</code> (OP: =, !=, -n, -z) <code>[ \"abc\" = \"abc\" ]</code> Verifica se duas strings s\u00e3o iguais Testes em ficheiros <code>OP FICH</code> (OP: -e, -f, -d, -r, -w, -x) <code>[ -f ficheiro.txt ]</code> Verifica se um ficheiro existe e \u00e9 regular expr express\u00e3o Opera\u00e7\u00f5es aritm\u00e9ticas <code>expr 5 + 3</code> Retorna <code>8</code>, equivalente a <code>5 + 3</code> $((express\u00e3o)) Avalia uma express\u00e3o <code>echo $((4 * 2))</code> Retorna <code>8</code>, usado para c\u00e1lculos matem\u00e1ticos"},{"location":"help/shell_scripting/#estruturas-de-controlo","title":"Estruturas de Controlo","text":""},{"location":"help/shell_scripting/#condicionais","title":"Condicionais","text":"<pre><code>if condi\u00e7\u00e3o\nthen\n    ...\nelif condi\u00e7\u00e3o\nthen\n    ...\nelse\n    ...\nfi\n</code></pre>"},{"location":"help/shell_scripting/#loop-while","title":"Loop <code>while</code>","text":"<pre><code>while condi\u00e7\u00e3o\ndo\n    ...\ndone\n</code></pre>"},{"location":"help/shell_scripting/#loops-for","title":"Loops <code>for</code>","text":"<pre><code>for vari\u00e1vel in lista\ndo\n    ...\ndone\n</code></pre> <p>ou</p> <pre><code>for ((exp1; exp2; exp3))\ndo\n    ...\ndone\n</code></pre>"},{"location":"lab02/ex02_01/","title":"Exerc\u00edcio 1","text":"<p>1.1. Abra o terminal do seu computador!</p> <ul> <li>Escreva o comando <code>pwd</code> explique o que \u00e9 indicado no seu terminal.</li> <li>Navegue at\u00e9 ao ambiente de trabalho (\"Secret\u00e1ria\"/\"Desktop\") ou outra diretoria \u00e0 escolha usando o terminal.</li> <li>Crie uma nova pasta usando <code>mkdir</code>.</li> <li>Navegue para essa pasta usando <code>cd</code>.</li> </ul> <p>1.2. Usando a linha de comandos, fa\u00e7a download do ficheiro <code>shell-data.zip</code> e extraia os ficheiros.</p> <ul> <li>O ficheiro est\u00e1 dispon\u00edvel em <code>https://s3-us-west-1.amazonaws.com/dib-training.ucdavis.edu/shell-data.zip</code></li> <li>Navegue at\u00e9 \u00e0 diretoria <code>data</code>.</li> <li>Liste os ficheiros existentes na diretoria <code>data</code>. Quantos ficheiros cont\u00e9m? De que tipo s\u00e3o?</li> <li>Encontre o ficheiro <code>youfoundit.txt</code>. Indique o seu caminho (path) partindo da diretoria <code>data</code>.</li> <li>Qual a diferen\u00e7a entre absolute path e relative path? Escreva o caminho do ficheiro <code>youfoundit.txt</code> usando o seu absolute path e o seu relative path (a partir da diretoria <code>tmp2</code>).</li> <li>Imprima o conte\u00fado do ficheiro <code>youfoundit.txt</code> para o terminal.</li> <li>Partindo da diretoria <code>.hidden</code>, use o comando <code>ls tmp*</code>. Indique o que \u00e9 impresso no terminal e a fun\u00e7\u00e3o do operador <code>*</code>. </li> <li>Crie uma c\u00f3pia do ficheiro <code>anotherfile.txt</code> para um novo ficheiro <code>yetanotherfile.txt</code>. O novo ficheiro deve ser guardado na diretoria <code>tmp3</code>.</li> <li>Mova o ficheiro <code>yetanotherfile.txt</code> para a diretoria <code>tmp2</code>.</li> <li>Crie uma nova diretoria (pasta) <code>tmp4</code> que tem dentro outra diretoria <code>tmp5</code>, que por sua vez tem a pasta `tmp6. Fa\u00e7a-o num s\u00f3 comando.</li> <li>Navegue novamente at\u00e9 \u00e0 diretoria <code>data</code> e crie um ficheiro vazio <code>empyfile.txt</code> na pasta <code>tmp6</code>.</li> <li>Elimine a diretoria <code>tmp5</code> e todo seu conte\u00fado.</li> </ul>"},{"location":"lab02/ex02_02/","title":"Exerc\u00edcio 2","text":"<p>2.1. Navegue agora at\u00e9 \u00e0 diretoria MiSeq que cont\u00e9m v\u00e1rios ficheiros FASTQ.</p> <ul> <li>Liste todos os ficheiros FASTQ existentes.</li> <li>Para cada amostra, existem dois ficheiros, R1 e R2. Liste todos os ficheiros FASTQ correspondentes \u00e0 sequencia\u00e7\u00e3o R1.</li> <li>Examine o ficheiro <code>F3D0_S188_L001_R1_001.fastq</code> usando o comando <code>cat</code>. </li> <li>Qual a diferen\u00e7a de usar o comando <code>less</code>?</li> <li>Usando o comando less, clique em <code>/</code>, procure a sequ\u00eancia <code>1101:14341</code> e copie o resultado.</li> </ul> Resultado Esperado <pre><code>@M00967:43:000000000-A3JHG:1:1101:14341:8428 1:N:0:188\nTACGTAGGGGGCAAGCGTTATCCGGATTTACTGGGTGTAAAGGGAGCGTAGACGGCCAGACAAGTCTGAAGTGAAAATCCAGCGCTTAACGTTGGAAGTGCTTTGGAAACTGCCGGGCTAGAGTGCAGGAGGGGCAGGCGGAATTCCTAGTGTAGCGGTGAAATGCGTAGATATTAGGAGGAACACCAGTGGCGAAGGCGGCCTGCTGGACTGCAACTGACGTTGAGGCTCGAAGGCGTGGGGAGCAAACA\n+\nCBCCCFFCCCCCGGGGGGGGGGHGGGGGHHHHHHHHGFGHHHHGHGGGGGGGHGGGGGGHGHHHHHHHHHHHHHHHHGHHHHHGGGGGHHGGHHHHHHGHHHHHHHHHHHHHHHGGGGGHHHHHHHHHHGGGGGGGGGGGGGGEGHHHHHHHHHHHGGDGGGGGGGGDDGGGGGGGGGGGGGGFBFFFE;FFFF-DAAEFFFFFFFFFFEFFEFFFFFFFFFEEFFFFE.FBBFEF.&gt;.-@@DAB..;FF.\n</code></pre> <ul> <li>Escreva agora apenas uma por\u00e7\u00e3o do ficheiro com o comando <code>head</code> para <code>head.txt</code>. Quantas linhas s\u00e3o impressas? </li> <li>Experimente agora o comando <code>tail</code>, escreva para <code>tail.txt</code> Quantas linhas s\u00e3o impressas?</li> <li>Imprima apenas as primeiras 5 linhas dos ficheiros <code>F3D0_S188_L001_R1_001.fastq</code> e <code>HMP_MOCK.v35.fasta</code>. Quais as principais diferen\u00e7as entre estes dois formatos?</li> <li>O comando <code>grep</code> tamb\u00e9m \u00e9 muito \u00fatil para procurar texto em ficheiros. Procure novamente pela sequ\u00eancia <code>1101:14341</code> no ficheiro <code>F3D0_S188_L001_R1_001.fastq</code> usando o comando <code>grep</code> (consulte <code>man grep</code> e investigue o melhor argumento para encontrar exactamente a mesma sequ\u00eancia que anteriormente).</li> <li>Procure a sequ\u00eancia <code>CATTAG</code> no ficheiro <code>F3D0_S188_L001_R2_001.fastq</code> e indique o id da(s) sequ\u00eancia(s) que encontrou (consulte <code>man grep</code> e investigue o melhor argumento).</li> </ul> Resultado Esperado <pre><code>@M00967:43:000000000-A3JHG:1:1105:19974:27855 2:N:0:188\nACTGTTCGATACCCACGCTTTCGTGCATTAGCGTCAGTTGCGCGCCGGTAGGCTGCCTTCGCAATCGGAGTTCTGCGTGATATCTATGCATTTCACCGCTACACCACGCATTCCGCCTAATTATCGCGCACTCAAGGCTCCCAGTTTCAACGGCGGAACGGGGTTGAGCCCCGCGATTTCACCGCTGACTTGAGGGTCCGCCTGCGCACCCTTTCAACCCAATAACTCCGGATAACGCCCCCATCCTCCGT\n</code></pre> <ul> <li>Em que linha a sequ\u00eancia <code>CATTAG</code> ocorre no ficheiro <code>F3D141_S207_L001_R1_001.fastq</code>?</li> </ul> Resultado Esperado <pre><code>2874:TACGTAGGGGGCAAGCGTTGTCCGGATTTATTGGGCGTAAAGCGAGTGCAGGCGGATCAATAAGTCTGCTGTGAAAGCCTTCGGCTCAACCGGAGAAATGCATTAGAAACTGTTTTACTTGAGTGCAGAAAAGGAGAGGGGAACTCCATGGGTAGGGGGGGAAGGCGAAAATATATGGAAAACCACCAGTGGGGAAGGAGCATCTCGGGGCTCCACTGGAGCCCATGGCTCGAAAGGATGGGATGCGAACG\n</code></pre> <ul> <li> <p>Imprima todas as ocorr\u00eancias da sequ\u00eancia <code>CATTAG</code> nos ficheiros <code>.fastq</code> da diretoria <code>MiSeq</code>. Escreva o resultado para um ficheiro <code>sequences_found.txt</code>.</p> </li> <li> <p>Em quantos ficheiros a sequ\u00eancia foi encontrada? Confirme recorrendo ao comando <code>wc</code> (investigue o operador <code>|</code>, pipe).</p> </li> </ul> Resultado Esperado <pre><code>119\n</code></pre>"},{"location":"lab02/ex02_03/","title":"Exerc\u00edcio 3","text":"<p>Como observou no exerc\u00edcio anterior, o pipe (<code>|</code>) \u00e9 muito utilizado para redirecionar a sa\u00edda (output, stdout) de um comando para a entrada (input, stdin) de outro comando, permitindo-nos encadear m\u00faltiplos comandos. Outros comandos muito utilizados s\u00e3o o <code>echo</code> (imprime para a consola), o <code>cut</code> (extrai sec\u00e7\u00f5es de cada linha de entrada) e o <code>sort</code> (usado para ordena\u00e7\u00e3o).</p> <p>3.1. Explore os seguintes comandos:</p> <ul> <li>O que fazem os comandos seguintes?<ul> <li><code>echo \u201chello, world\u201d</code></li> <li><code>echo \u201chello, world\u201d | cut -d, -f1</code></li> </ul> </li> <li>Crie um ficheiro <code>fruits.txt</code> com o conte\u00fado de algumas frutas (uma por linha) e um ficheiro <code>numbers.txt</code> com alguns n\u00fameros (um por linha). <ul> <li>O que retorna o comando <code>sort fruits.txt</code>? </li> <li>O que retorna o comando <code>sort numbers.txt</code>? </li> <li>Que altera\u00e7\u00e3o deve fazer para ordenar o ficheiro <code>numbers.txt</code>?</li> <li>Experimente a ordem reversa tamb\u00e9m. Consulte <code>man sort</code>.</li> </ul> </li> <li>Escreva o comando que retira o sufixo <code>001</code> ao nome do ficheiro <code>F3D141_S207_L001_R1_001.fq</code>. Por exemplo, o comando <code>echo F3D141_S207_L001_R1_001.fq &lt;termine o comando&gt;</code> dever\u00e1 retornar: <pre><code>F3D141_S207_L001_R1\n</code></pre></li> </ul> <p>3.2. Fa\u00e7a download do ficheiro abaixo e extraia o seu conte\u00fado:</p> <ul> <li>O ficheiro encontra-se em <code>http://igenomes.illumina.com.s3-website-us-east-1.amazonaws.com/PhiX/Illumina/RTA/PhiX_Illumina_RTA.tar.gz</code>(considere os comandos <code>wget</code> e <code>tar</code>). </li> <li>Fa\u00e7a uma c\u00f3pia do ficheiro <code>/PhiX/Illumina/RTA/Sequence/WholeGenomeFasta/genome.fa</code> para um novo ficheiro chamado <code>phix.fa</code>.</li> <li>Considere agora o ficheiro <code>phix.fa</code>. Conte o n\u00famero de linhas e nucle\u00f3tidos do ficheiro.</li> </ul> Resultado Esperado <pre><code>2       2    5393 phix.fa\n1       1    5387  \n</code></pre> <ul> <li>Determine a sequ\u00eancia de nucle\u00f3tidos 640 a 700:</li> </ul> Resultado Esperado <pre><code>ATTATGTTCATCCCGTCAACATTCAAACGGCCTGTCTCATCATGGAAGGCGCTGAATTTAC\n</code></pre> <ul> <li>Indique o que faz o comando <code>grep -\u2013color \"ATG......\" phix.fa</code> e explique o seu output.</li> <li>Que comando <code>grep</code> dever\u00e1 usar para imprimir apenas as ocorr\u00eancias de interesse? Consulte <code>man grep</code>.</li> <li>Quantas sequ\u00eancias encontrou? Use o comando <code>wc</code>.</li> <li>Utilize o comando <code>cut</code> para obter apenas o segundo cod\u00e3o das ocorr\u00eancias (considere pipes).</li> </ul> Resultado Esperado <pre><code>ACG\nAGT\nAGA\nAGG\n...\n</code></pre> <ul> <li>Usando o comando sort, ordene alfabeticamente as sequ\u00eancias de segundos cod\u00f5es (considere pipes).</li> </ul> Resultado Esperado <pre><code>AAA\nAAA\nAAG\nAAG\n...\n</code></pre> <ul> <li>Quantas vezes cada segundo cod\u00e3o se encontra repetido? Encontre as repeti\u00e7\u00f5es de cada cod\u00e3o com o comando <code>uniq</code>. Considere pipes e consulte <code>man uniq</code>.</li> </ul> Resultado Esperado <pre><code>2 AAA\n2 AAG\n1 AAT\n1 ACA\n...\n</code></pre> <ul> <li>Ordene a lista anterior por ordem decrescente, de forma a encontrar os segundos cod\u00f5es mais comuns (considere pipes):</li> </ul> Resultado Esperado <pre><code>7 GTT\n6 CTT\n6 AGT\n5 TTT\n...\n</code></pre> <ul> <li>Considere novamente a sequ\u00eancia completa do ficheiro <code>phix.fa</code>. Considere o 3\u00ba cod\u00e3o acima de cada cod\u00e3o de paragem <code>TGA</code> (e.g., <code>cod3-cod2-cod1-TGA</code>). Qual \u00e9 o cod\u00e3o mais frequente que aparece em <code>cod3</code>?</li> </ul> Resultado Esperado <pre><code>8 TGC\n</code></pre> <ul> <li>Usando pipes, escreva um comando que conte os primeiros 100 nucle\u00f3tidos da sequ\u00eancia do ficheiro <code>phix.fa</code>. Quantas Adeninas (<code>A</code>) existem?</li> </ul> Resultado Esperado <pre><code>30\n</code></pre>"},{"location":"lab02/ficheiros/","title":"Manipula\u00e7\u00e3o de Ficheiros","text":"<p>Existem v\u00e1rios comandos que permitem realizar opera\u00e7\u00f5es com ficheiros como copiar, mover, mudar o nome, criar e visualizar o seu conte\u00fado. Estes comandos s\u00e3o essenciais para manter a estrutura de ficheiros organizada e facilitar a navega\u00e7\u00e3o e edi\u00e7\u00e3o de dados.</p>"},{"location":"lab02/ficheiros/#navegacao-criacao-eliminacao","title":"Navega\u00e7\u00e3o, Cria\u00e7\u00e3o, Elimina\u00e7\u00e3o","text":"<ul> <li><code>pwd</code>: Mostra a diretoria atual</li> <li><code>ls</code>: Lista as pastas e ficheiros na diretoria atual</li> <li><code>cd &lt;diretoria&gt;</code>: Muda para a diretoria especificada</li> <li><code>mkdir &lt;diretoria&gt;</code>: Cria uma nova diretoria</li> <li><code>rmdir &lt;diretoria&gt;</code>: Remove uma diretoria</li> </ul> <p>Exemplos</p> <pre><code>pwd                     # Mostra a diretoria atual\nls                      # Lista as pastas e ficheiros na diretoria atual\ncd Documentos           # Muda para a diretoria \"Documentos\"\nmkdir projeto_bioinf    # Cria a pasta \"projeto_bioinf\"\nrmdir projeto_bioinf    # Apaga a pasta \"projeto_bioinf\"\n</code></pre>"},{"location":"lab02/ficheiros/#operacoes-com-ficheiros","title":"Opera\u00e7\u00f5es com Ficheiros","text":"<ul> <li><code>cp &lt;origem&gt; &lt;destino&gt;</code>: Copia um ficheiro de um local para outro</li> <li><code>mv &lt;origem&gt; &lt;destino&gt;</code>: Move ou muda o nome de um ficheiro</li> <li><code>rm &lt;ficheiro&gt;</code>: Apaga um ficheiro</li> <li><code>touch &lt;ficheiro&gt;</code>: Cria um ficheiro vazio</li> <li><code>cat &lt;ficheiro&gt;</code>: Mostra o conte\u00fado de um ficheiro</li> <li><code>less &lt;ficheiro&gt;</code>: Mostra o conte\u00fado de um ficheiro p\u00e1gina por p\u00e1gina</li> <li><code>head -n &lt;n\u00famero&gt; &lt;ficheiro&gt;</code>: Exibe as primeiras n linhas de um ficheiro</li> <li><code>tail -n &lt;n\u00famero&gt; &lt;ficheiro&gt;</code>: Exibe as \u00faltimas n linhas de um ficheiro</li> </ul> <p>Exemplos</p> <pre><code>cp ficheiro.txt backup.txt           # Copia \"ficheiro.txt\" para \"backup.txt\"\nmv nome_antigo.txt nome_novo.txt     # Renomeia o ficheiro \"nome_antigo.txt\" para \"nome_novo.txt\"\nrm ficheiro_indesejado.txt           # Remove \"ficheiro_indesejado.txt\"\ntouch novo_ficheiro.txt              # Cria um ficheiro vazio chamado \"novo_ficheiro.txt\"\ncat exemplo.txt                      # Mostra o conte\u00fado do ficheiro \"exemplo.txt\"\nless ficheiro_grande.txt             # Mostra o conte\u00fado do \"ficheiro_grande.txt\" p\u00e1gina por p\u00e1gina\nhead -n 10 ficheiro.txt              # Mostra as primeiras 10 linhas do \"ficheiro.txt\"\ntail -n 10 ficheiro.txt              # Mostra as \u00faltimas 10 linhas do \"ficheiro.txt\"\n</code></pre>"},{"location":"lab02/ficheiros/#operacoes-de-procura-em-ficheiros","title":"Opera\u00e7\u00f5es de Procura em Ficheiros","text":"<ul> <li><code>find &lt;diretoria&gt; -name \"*.extens\u00e3o\"</code>: Encontra ficheiro por nome e extens\u00e3o</li> <li><code>grep \"padr\u00e3o\" &lt;ficheiro&gt;</code>: Pesquisa por um padr\u00e3o de texto dentro de um ficheiro</li> <li><code>wc -l &lt;ficheiro&gt;</code>: Conta o n\u00famero de linhas num ficheiro</li> <li><code>sort &lt;ficheiro&gt;</code>: Mostra as linhas de um ficheiro ordenadas</li> <li><code>uniq &lt;ficheiro&gt;</code>: Mostra as linhas \u00fanicas de um ficheiro</li> </ul> <p>Exemplos</p> <pre><code>find /home/user -name \"*.fasta\"         # Encontra arquivos com extens\u00e3o \".fasta\" na diretoria /home/user\ngrep \"ATGC\" sequencias.fasta            # Pesquisa o padr\u00e3o \"ATGC\" no ficheiro \"sequencias.fasta\"\nwc -l dados.txt                         # Conta o n\u00famero de linhas no arquivo \"dados.txt\"\nsort nomes.txt                          # Ordena as linhas do ficheiro \"nomes.txt\"\nsort nomes.txt | uniq                   # Ordena as linhas do arquivo \"nomes.txt\", removendo as duplicadas\n</code></pre>"},{"location":"lab02/ficheiros/#redireccionamento","title":"Redireccionamento","text":"<p>O redirecionamento permite controlar de onde vem a entrada de um comando e para onde vai a sua sa\u00edda. Ess processo pode ser indicado atrav\u00e9s dos seguintes s\u00edmbolos:</p> <ul> <li><code>&gt;</code>: Redireciona a sa\u00edda para um ficheiro (faz \"overwrite\" ao ficheiro, i.e., \"escreve por cima\").  </li> <li><code>&gt;&gt;</code>: Redireciona a sa\u00edda para um ficheiro, adicionando ao final caso o ficheiro j\u00e1 exista.  </li> <li><code>&lt;</code>: Redireciona a entrada de um ficheiro.  </li> </ul>"},{"location":"lab02/ficheiros/#sobrescrever-um-ficheiro","title":"Sobrescrever um Ficheiro (<code>&gt;</code>)","text":"<p>O s\u00edmbolo <code>&gt;</code> redireciona a sa\u00edda (stdout) de um comando para um ficheiro. Se o ficheiro j\u00e1 existir, o conte\u00fado \u00e9 substitu\u00eddo.  </p> <p>Por exemplo, podes edirecionar a sa\u00edda de <code>echo</code> para um ficheiro <code>output.txt</code>: <pre><code>echo \"Ol\u00e1, Bioinform\u00e1tica!\" &gt; output.txt\n</code></pre> Este comando cria um ficheiro chamado <code>output.txt</code> (ou substitiu o seu conte\u00fado se ele j\u00e1 existir), escrevendo \"Ol\u00e1, Bioinform\u00e1tica!\".</p>"},{"location":"lab02/ficheiros/#adicionar-ao-final-de-um-ficheiro","title":"Adicionar ao Final de um Ficheiro (<code>&gt;&gt;</code>)","text":"<p>Para adicionar dados ao final de um ficheiro sem substituir o seu conte\u00fado usamos <code>&gt;&gt;</code>.  </p> <p>Por exemplo, podes adicionar data e hora atual a um ficheiro de registo (log): <pre><code>date &gt;&gt; log.txt\n</code></pre> Este comando adiciona a data e hora atual ao ficheiro <code>log.txt</code> sem apagar o conte\u00fado existente.  </p>"},{"location":"lab02/ficheiros/#redirecionar-a-entrada-de-um-ficheiro","title":"Redirecionar a Entrada de um Ficheiro (<code>&lt;</code>)","text":"<p>Em vez de escrevermos a entrada manualmente no terminal, podemos usar <code>&lt;</code> para indicar a entrada de um ficheiro. Nalgumas situa\u00e7\u00f5es, esoecialmente com comandos que n\u00e3o aceitam ficheiros como argumento, usar o <code>&lt;</code> \u00e9 vantajoso. Por exemplo, no comando seguinte o <code>tr</code> converte as letras min\u00fasculas em mai\u00fasculas, mas n\u00e3o aceita ficheiros diretamente como argumento. Usar <code>&lt;</code> garante que o conte\u00fado do <code>texto.txt</code> \u00e9 passado para o <code>tr</code> atrav\u00e9s da entrada padr\u00e3o:</p> <pre><code>tr 'a-z' 'A-Z' &lt; texto.txt\n</code></pre>"},{"location":"lab02/intro/","title":"Introdu\u00e7\u00e3o \u00e0 Linha de Comandos","text":"<p>A linha de comandos (command line ou command prompt) \u00e9 uma interface de texto onde podemos interagir com o sistema operativo do computador executando comandos directamente. Ou seja, em vez de usarmos uma interface gr\u00e1fica com \u00edcones e menus, a linha de comandos permite-nos executar programas, aceder a ficheiros e realizar muitas outras tarefas diretamente, atrav\u00e9s de comandos de texto.</p> <p>No Windows, podemos aceder \u00e0 linha de comandos atrav\u00e9s da Command Prompt (cmd.exe ou cmd) ou PowerShell, enquanto que no Linux ou macOS, \u00e9 usado o Terminal.</p>"},{"location":"lab02/intro/#comandos-basicos","title":"Comandos B\u00e1sicos","text":"<p>\"Comandos\" s\u00e3o essencialmente instru\u00e7\u00f5es que podemos escrever num terminal (ou command prompt) para interagir com o sistema operativo. Dependendo do sistema operativo (e.g., Windows ou Linux/macOS), os comandos podem ser ligeiramente diferentes:</p>"},{"location":"lab02/intro/#comandos-basicos-no-windows","title":"Comandos B\u00e1sicos no Windows","text":"Comando Descri\u00e7\u00e3o Exemplo <code>dir</code> Lista as pastas/ficheiros na diretoria atual <code>dir</code> <code>cd</code> Altera a diretoria de trabalho <code>cd nome_da_pasta</code> <code>cls</code> Limpa a tela do terminal <code>cls</code> <code>del</code> Elimina um ficheiro <code>del nome_do_ficheiro.txt</code> <code>exit</code> Fecha a linha de comandos <code>exit</code>"},{"location":"lab02/intro/#comandos-basicos-no-linuxmacos","title":"Comandos B\u00e1sicos no Linux/macOS","text":"Comando Descri\u00e7\u00e3o Exemplo <code>ls</code> Lista as pastas/ficheiros na diretoria atual <code>ls</code> <code>cd</code> Altera a diretoria de trabalho <code>cd nome_da_pasta</code> <code>pwd</code> Mostra o caminho completo da diretoria atual <code>pwd</code> <code>rm</code> Elimina um ficheiro <code>rm nome_do_ficheiro.txt</code> <code>clear</code> Limpa a tela do terminal <code>clear</code> <p>Aten\u00e7\u00e3o!</p> <p>Nos Laborat\u00f3rios de Bioinform\u00e1tica, vamos focar-nos mais no sistema operativo Unix (portanto a maioria dos comandos apresentados funcionar\u00e3o para Linux e macOS, sendo que nalguns casos poder\u00e3o ter de consultar o comando equivalente no Windows).</p>"},{"location":"lab02/manual/","title":"Manual (man)","text":"<p>Nem sempre sabemos de cor como usar todos os comandos, mas podemos consultar o manual do sistema atrav\u00e9s do comando <code>man</code>, que nos fornece informa\u00e7\u00f5es sobre como usar os comandos, a sua sintaxe, as op\u00e7\u00f5es dispon\u00edveis e alguns exemplos. Cada comando tem tipicamente uma p\u00e1gina correspondente.</p>"},{"location":"lab02/manual/#utilizacao-basica-do-man","title":"Utiliza\u00e7\u00e3o B\u00e1sica do <code>man</code>","text":"<p>Para aceder \u00e0 p\u00e1gina de um comando, podemos usar o seguinte comando:</p> <pre><code>man &lt;comando&gt;\n</code></pre> <p>Exemplo</p> <pre><code>man ls      # Mostra a p\u00e1gina do manual para o comando 'ls'\nman grep    # Mostra detalhes sobre o comando 'grep'\nman wget    # Mostra a documenta\u00e7\u00e3o do comando 'wget'\n</code></pre> <p>A p\u00e1gina do manual est\u00e1 dividida em v\u00e1rias sec\u00e7\u00f5es:</p> <p>Sec\u00e7\u00f5es do Manual</p> <ul> <li>NAME: O nome do comando e uma descri\u00e7\u00e3o breve.</li> <li>SYNOPSIS: Um resumo da sintaxe do comando.</li> <li>DESCRIPTION: Informa\u00e7\u00f5es detalhadas sobre o comando e suas op\u00e7\u00f5es.</li> <li>OPTIONS: Uma lista das op\u00e7\u00f5es do comando e o que elas fazem.</li> <li>EXAMPLES: Exemplos pr\u00e1ticos de como usar o comando.</li> <li>SEE ALSO: Links para comandos e p\u00e1ginas de manual relacionadas.</li> </ul>"},{"location":"lab02/manual/#navegar-pelas-paginas-do-man","title":"Navegar pelas p\u00e1ginas do <code>man</code>","text":"<p>Dentro de uma p\u00e1gina do manual, podemos navegar usando as seguintes teclas:</p> <p>Navega\u00e7\u00e3o no Manual</p> <ul> <li>Espa\u00e7o: Avan\u00e7ar uma p\u00e1gina.</li> <li>b: Retroceder uma p\u00e1gina.</li> <li>Enter: Avan\u00e7ar uma linha.</li> <li>/termo_de_busca: Procurar por uma palavra espec\u00edfica dentro do manual.</li> <li>n: Avan\u00e7ar para o pr\u00f3ximo resultado da pesquisa.</li> <li>q: Sair do manual e voltar ao terminal.</li> </ul>"},{"location":"lab02/manual/#exemplos-explorar-os-comandos-ls-grep-e-cut","title":"Exemplos: Explorar os comandos <code>ls</code>, <code>grep</code> e <code>cut</code>","text":"<p>Explorar o comando <code>ls</code></p> <p>Para ver a p\u00e1gina do manual para o comando <code>ls</code>, podemos escrever:</p> <p><pre><code>man ls\n</code></pre> O manual mostra as seguintes sec\u00e7\u00f5es:</p> <ul> <li>SYNOPSIS: <pre><code>ls [OPTION]... [FILE]...\n</code></pre></li> <li> <p>OPTIONS:</p> <ul> <li><code>-l</code>: Listar ficheiros no formato longo</li> <li><code>-a</code>: Mostrar todos os ficheiros, incluindo os ocultos</li> </ul> </li> <li> <p>EXAMPLES: <pre><code>ls -lh  # Lista os ficheiros com tamanhos leg\u00edveis\nls -a   # Lista todos os ficheiros, incluindo os ocultos\n</code></pre></p> </li> </ul> <p>Explorar o comando <code>grep</code></p> <p>O comando <code>grep</code> \u00e9 frequentemente utilizado para procurar padr\u00f5es em ficheiros. Para explor\u00e1-lo:</p> <pre><code>man grep\n</code></pre> <p>Sec\u00e7\u00f5es que podemos ver:</p> <ul> <li>SYNOPSIS: <pre><code>grep [OPTION]... PATTERN [FILE]...\n</code></pre></li> <li> <p>OPTIONS:</p> <ul> <li><code>-i</code>: Ignorar mai\u00fasculas/min\u00fasculas na pesquisa.</li> <li><code>-v</code>: Inverter a correspond\u00eancia (mostrar apenas as linhas que n\u00e3o coincidem).</li> <li><code>-r</code>: Buscar recursivamente em pastas/diretorias.</li> </ul> </li> <li> <p>EXAMPLES: <pre><code>grep -i \"ATGC\" file.fasta   # Pesquisa sem considerar mai\u00fasculas/min\u00fasculas pelo padr\u00e3o \"ATGC\"\ngrep -r \"padr\u00e3o\" diretoria  # Pesquisa recursiva pelo padr\u00e3o \"padr\u00e3o\" em todos os arquivos de uma diretoria\n</code></pre></p> </li> </ul> <p>Explorar o comando <code>cut</code></p> <p>O comando <code>cut</code> \u00e9 \u00fatil para extrair colunas de arquivos, e por isso frequentement utilizado em conjuntos de dados de bioinform\u00e1tica como ficheiros CSV.</p> <pre><code>man cut\n</code></pre> <p>Sec\u00e7\u00f5es chave:</p> <ul> <li> <p>SYNOPSIS: <pre><code>cut [OPTION]... [FILE]...\n</code></pre></p> </li> <li> <p>OPTIONS:</p> <ul> <li><code>-f &lt;campos&gt;</code>: Seleciona campos espec\u00edficos (colunas).</li> <li><code>-d &lt;delimitador&gt;</code>: Especifica o delimitador entre os campos.</li> </ul> </li> <li> <p>EXAMPLES: <pre><code>cut -f1,3 -d',' file.csv   # Extrai as colunas 1 e 3 de um ficheiro CSV\ncut -c1-5 file.txt         # Extrai os primeiros 5 caracteres de cada linha\n</code></pre></p> </li> </ul>"},{"location":"lab02/manual/#argumentos-e-opcoes","title":"Argumentos e Op\u00e7\u00f5es","text":"<p>Muitos commandos aceitam argumentos e op\u00e7\u00f5es para modificar o seu comportamento:</p> <p>Exemplos</p> <pre><code>ls -l               # Lista os ficheiros em formato longo (com detalhes)\nls -a               # Lista todos os ficheiros, incluindo os ocultos\nrm -r pasta/        # Remove a \"pasta\" e todo o seu conte\u00fado\n</code></pre> <p>Os argumentos s\u00e3o entradas/informa\u00e7\u00e3o fornecidas a um comando para indicar sobre o que ele deve atuar, tal como o nome de um ficheiro ou diretoria:  </p> <pre><code>cat ficheiro.txt  # 'ficheiro.txt' \u00e9 um argumento passado para o comando 'cat'\n</code></pre> <p>As op\u00e7\u00f5es (tamb\u00e9m chamadas flags) modificam o comportamento de um comando. Normalmente, s\u00e3o precedidas por um tra\u00e7o (<code>-</code>) para op\u00e7\u00f5es curtas ou por dois tra\u00e7os (<code>--</code>) para op\u00e7\u00f5es mais longas:</p> <ul> <li>Op\u00e7\u00f5es Curtas: <ul> <li>Come\u00e7am com um \u00fanico tra\u00e7o (<code>-</code>).</li> <li>Usam uma \u00fanica letra (<code>-l</code>, <code>-a</code>, <code>-r</code>, etc.).</li> <li>Podem ser combinadas sem espa\u00e7os (<code>-la</code> \u00e9 o mesmo que <code>-l -a</code>).</li> <li>S\u00e3o mais r\u00e1pidas de digitar, mas menos descritivas.</li> </ul> </li> </ul> <p>Op\u00e7\u00f5es Curtas</p> <pre><code>ls -l                             # '-l' \u00e9 uma op\u00e7\u00e3o que exibe informa\u00e7\u00f5es detalhadas sobre os ficheiros\nls -a                             # Exibir ficheiros ocultos\ngrep -i \"padr\u00e3o\" ficheiro.txt     # Pesquisa sem diferenciar mai\u00fasculas/min\u00fasculas\ngrep -c \"padr\u00e3o\" ficheiro.txt     # Conta o n\u00famero de ocorr\u00eancias do padr\u00e3o\nsort -r ficheiro.txt              # Ordena\u00e7\u00e3o reversa\nsort -u ficheiro.txt              # Remove duplicados ao ordenar\nls -l -a                          # Listar arquivos em formato detalhado e incluir ocultos\nls -la                            # O mesmo que acima, combinando as op\u00e7\u00f5es\n</code></pre> <ul> <li>Op\u00e7\u00f5es Longas:<ul> <li>Come\u00e7am com dois tra\u00e7os (<code>--</code>).</li> <li>S\u00e3o palavras completas (<code>--all</code>, <code>--recursive</code>, <code>--verbose</code>, etc.).</li> <li>N\u00e3o podem ser combinadas e precisam de ser usadas separadamente.</li> <li>S\u00e3o mais f\u00e1ceis de entender, mas mais longas para digitar.</li> </ul> </li> </ul> <p>Op\u00e7\u00f5es Longas</p> <pre><code>ls --all                                   # Mostra todos os ficheiros, incluindo os ocultos\ngrep -i \"padr\u00e3o\" ficheiro.txt              # Op\u00e7\u00e3o curta (-i) para ignorar mai\u00fasculas/min\u00fasculas\ngrep --ignore-case \"padr\u00e3o\" ficheiro.txt   # Op\u00e7\u00e3o longa equivalente\n</code></pre> <p>Para comandos frequentes, as op\u00e7\u00f5es curtas s\u00e3o mais r\u00e1pidas (<code>ls -l</code>). Para scripts e comandos mais complexos, as op\u00e7\u00f5es longas s\u00e3o mais leg\u00edveis (<code>tar --verbose --extract --file=backup.tar</code>).</p>"},{"location":"lab02/pipes/","title":"Utiliza\u00e7\u00e3o de Pipes (<code>|</code>)","text":""},{"location":"lab02/pipes/#o-que-e-um-pipe","title":"O que \u00e9 um Pipe?","text":"<p>Um pipe (<code>|</code>) \u00e9 uma funcionalidade que permite ligar a sa\u00edda de um comando diretamente \u00e0 entrada de outro comando. Isto possibilita a cria\u00e7\u00e3o de uma sequ\u00eancia de opera\u00e7\u00f5es -- ou um pipeline -- onde a sa\u00edda de um comando \u00e9 processada pelo comando seguinte na cadeia.  </p> <p>Em vez de executarmos cada comando separadamente e gerirmos manualmente ficheiros interm\u00e9dios, podemos passar dados de um comando para outro, tornando o fluxo mais eficiente. Isto \u00e9 especialmente \u00fatil quando se lida com grandes volumes de dados em bioinform\u00e1tica, onde m\u00faltiplas etapas de processamento podem ser combinadas numa \u00fanica linha de comando.  </p>"},{"location":"lab02/pipes/#sintaxe-basica","title":"Sintaxe B\u00e1sica","text":"<p>A sintaxe b\u00e1sica para usar pipes \u00e9: </p> <pre><code>comando1 | comando2 | comando3\n</code></pre> <p>Neste caso, a sa\u00edda do <code>comando1</code> \u00e9 passada como entrada para o <code>comando2</code> e a sa\u00edda do <code>comando2</code> \u00e9 passada para o <code>comando3</code>.  </p>"},{"location":"lab02/pipes/#exemplos","title":"Exemplos","text":"<p>Combinar <code>ls</code> e <code>grep</code></p> <p>Para listar todos os ficheiros numa diretoria e depois filtrar apenas os ficheiros <code>.txt</code>, podes usar o <code>ls</code> em combina\u00e7\u00e3o com o <code>grep</code> utilizando um pipe: <pre><code>ls | grep \".txt\"\n</code></pre> - <code>ls</code> lista todos os ficheiros na diretoria atual. - <code>grep \".txt\"</code> filtra a sa\u00edda e mostra apenas as linhas que cont\u00eam <code>.txt</code>.  </p> <p>Combinar <code>cat</code>, <code>grep</code> e <code>sort</code></p> <p>Se tiveres um ficheiro de texto grande e quiseres contar as ocorr\u00eancias de uma palavra espec\u00edfica (por exemplo, \"gene\"), podes ordenar a sa\u00edda e mostrar os 10 resultados mais frequentes: <pre><code>cat ficheiro.txt | grep -o \"gene\" | sort | uniq -c | sort -nr | head -n 10\n</code></pre> - <code>cat ficheiro.txt</code> mostra o conte\u00fado do ficheiro. - <code>grep -o \"gene\"</code> extrai todas as ocorr\u00eancias da palavra \"gene\". - <code>sort</code> ordena as ocorr\u00eancias alfabeticamente. - <code>uniq -c</code> conta o n\u00famero de ocorr\u00eancias de cada palavra. - <code>sort -nr</code> ordena os contadores por ordem decrescente. - <code>head -n 10</code> mostra os 10 resultados mais comuns.  </p> <p>Combinar <code>wc</code> e <code>sort</code></p> <p>Para contar o n\u00famero de sequ\u00eancias (linhas que come\u00e7am com <code>&gt;</code>) em v\u00e1rios ficheiros FASTA e orden\u00e1-los pelo n\u00famero de sequ\u00eancias, podes usar: <pre><code>grep -c \"^&gt;\" *.fasta | sort -n\n</code></pre> - <code>grep -c \"^&gt;\" *.fasta</code> conta o n\u00famero de sequ\u00eancias em cada ficheiro FASTA. - <code>sort -n</code> ordena os resultados por ordem crescente.  </p> <p>Combinar <code>cut</code> e <code>sort</code></p> <p>Se tiveres um ficheiro tabulado (<code>data.csv</code>) e quiseres extrair a primeira e a terceira colunas, orden\u00e1-las e remover duplicados, podes usar: <pre><code>cut -f1,3 data.tsv | sort | uniq\n</code></pre> - <code>cut -f1,3 data.csv</code> extrai as colunas 1 e 3 do ficheiro. - <code>sort</code> ordena os dados. - <code>uniq</code> remove as linhas duplicadas.  </p>"},{"location":"lab02/pipes/#casos-praticos-em-bioinformatica","title":"Casos Pr\u00e1ticos em Bioinform\u00e1tica","text":"<p>Os pipes s\u00e3o especialmente \u00fateis na bioinform\u00e1tica, onde a manipula\u00e7\u00e3o de grandes volumes de dados \u00e9 frequente. Combinando comandos simples, \u00e9 poss\u00edvel processar, analisar e organizar sequ\u00eancias biol\u00f3gicas de forma r\u00e1pida e eficiente, sem necessidade de software complexo. Eis alguns exemplos:</p> <ul> <li> <p>Contar o N\u00famero de Sequ\u00eancias num Ficheiro FASTA    Para contar as sequ\u00eancias em v\u00e1rios ficheiros FASTA: <pre><code>grep -c \"^&gt;\" *.fasta | sort -n\n</code></pre></p> </li> <li> <p>Analisar Dados de Sequ\u00eancias    Para encontrar todas as ocorr\u00eancias de um motif (<code>ATGC</code>) num conjunto de ficheiros FASTA e contar quantas vezes aparece: <pre><code>grep -o \"ATGC\" *.fasta | wc -l\n</code></pre></p> </li> <li> <p>Limpar e Organizar Dados    Para remover linhas duplicadas num ficheiro de texto grande: <pre><code>sort ficheiro.txt | uniq &gt; ficheiro_limpo.txt\n</code></pre></p> </li> </ul>"},{"location":"lab02/wildcards/","title":"Wildcards","text":"<p>Os wildcards s\u00e3o caracteres especiais usados para representar um ou mais caracteres nos nomes de ficheiros, facilitando a sele\u00e7\u00e3o e manipula\u00e7\u00e3o de m\u00faltiplos ficheiros ao mesmo tempo. S\u00e3o particularmente \u00fateis quando se trabalha com um grande n\u00famero de ficheiros que seguem uma conven\u00e7\u00e3o de nomenclatura semelhante, algo muito comum em bioinform\u00e1tica (por exemplo, ficheiros de sequ\u00eancias, ficheiros de alinhamento, etc.).  </p>"},{"location":"lab02/wildcards/#wildcards-comuns","title":"Wildcards Comuns","text":"<ul> <li> <p>Asterisco (<code>*</code>):</p> <ul> <li>Corresponde a zero ou mais caracteres.  </li> <li>\u00c9 o wildcard mais utilizado para corresponder a m\u00faltiplos ficheiros ou partes de nomes de ficheiros.  </li> </ul> <p>Exemplos</p> <pre><code>ls *.txt       # Lista todos os ficheiros que terminam em .txt\nls sample*     # Lista todos os ficheiros que come\u00e7am com \"sample\" (e.g., 'sample1.txt', 'sample_data.csv', etc.)\n</code></pre> </li> <li> <p>Ponto de Interroga\u00e7\u00e3o (<code>?</code>):</p> <ul> <li>Corresponde exatamente a um caracter.</li> <li>\u00datil para corresponder a nomes de ficheiros que diferem por apenas um caracter.  </li> </ul> <p>Exemplos</p> <pre><code>ls file?  # Listar ficheiros com exatamente 5 caracteres, come\u00e7ando por `file (e.g., 'file1', 'fileA', 'filex', etc.)\nls *.???  # Corresponde a qualquer ficheiro com uma extens\u00e3o de 3 caracteres (e.g.,'dados.txt', 'sequencias.fna', etc.)\n</code></pre> </li> <li> <p>Par\u00eantesis Rectos (<code>[]</code>):</p> <ul> <li>Corresponde a qualquer um dos caracteres especificados dentro dos par\u00eantesis.</li> <li>Pode incluir letras, n\u00fameros ou intervalos de caracteres.  </li> </ul> <p>Exemplos</p> <pre><code>ls data[123]    # Qualquer ficheiro que comece com `data` e termine em `1`, `2` ou `3` (e.g., 'data1', 'data2', 'data3')\n</code></pre> </li> <li> <p>H\u00edfen (<code>-</code>) dentro de Par\u00eanteses Rectos:</p> <ul> <li>Representa um intervalo de caracteres.  </li> </ul> <p>Exemplos</p> <pre><code>ls [a-z]*          # Ficheiros que comecem por uma letra min\u00fascula (`a` a `z`), (e.g., 'banana.csv', 'arquivo.txt', etc.)\nls file[1-3].txt   # Ficheiros com um n\u00famero entre `1` e `3` (e.g., 'file1.txt', 'file2.txt', 'file3.txt')\n</code></pre> </li> <li> <p>Circunflexo (<code>^</code>) dentro de Par\u00eantesis Rectos: </p> <ul> <li>Quando usado no in\u00edcio da express\u00e3o dentro dos par\u00eantesis rectos, o circunflexo (<code>^</code>) nega o padr\u00e3o, correspondendo a qualquer car\u00e1cter excepto os especificados.  </li> </ul> <p>Exemplos</p> <pre><code>ls [^ab]*  # Ficheiros que N\u00c3O comecem por `a` ou `b` (e.g., 'casa.txt', 'dados.fna', mas n\u00e3o 'apple.txt')\n</code></pre> </li> </ul>"},{"location":"lab02/wildcards/#combinar-wildcards-com-outros-comandos","title":"Combinar Wildcards com Outros Comandos","text":"<p>Os wildcards s\u00e3o frequentemente usados com comandos como <code>ls</code>, <code>cp</code>, <code>mv</code>, <code>rm</code> e outros para operar em m\u00faltiplos ficheiros ao mesmo tempo.  </p> <p>Listar Ficheiros com Wildcards</p> <p>Para listar todos os ficheiros <code>.fastq</code> numa diretoria: <pre><code>ls *.fastq  # Lista todos os ficheiros com extens\u00e3o .fastq\n</code></pre> Para listar todos os ficheiros que come\u00e7am com <code>seq</code> e t\u00eam qualquer extens\u00e3o: <pre><code>ls seq*.*  # Corresponde a seq1.fasta, seq2.fastq, seq3.txt, etc.\n</code></pre></p> <p>Copiar Ficheiros com Wildcards</p> <p>Para copiar todos os ficheiros <code>.fasta</code> de uma diretoria para outra: <pre><code>cp *.fasta /caminho/do/destino/\n</code></pre></p> <p>Remover Ficheiros com Wildcards</p> <p>Para remover todos os ficheiros <code>.log</code> numa diretoria: <pre><code>rm *.log  # Remove todos os ficheiros com extens\u00e3o .log\n</code></pre></p> <p>Procurar Ficheiros com Wildcards</p> <p>Tamb\u00e9m \u00e9 poss\u00edvel usar wildcards com <code>grep</code> para pesquisar padr\u00f5es em ficheiros. Por exemplo, para procurar a sequ\u00eancia <code>ATGC</code> em todos os ficheiros FASTA: <pre><code>grep \"ATGC\" *.fasta  # Pesquisa \"ATGC\" em todos os ficheiros .fasta\n</code></pre></p>"},{"location":"lab03/awk/","title":"O comando <code>awk</code>","text":"<p>O <code>awk</code> \u00e9 uma linguagem muito \u00fatil para processar ficheiros semi-estruturados ou estruturados atrav\u00e9s da manipula\u00e7\u00e3o de padr\u00f5es (patterns) especificados atrav\u00e9s de express\u00f5es regulares (regular expressions), o que o torna muito vers\u00e1til. O comando <code>awk</code> permite-nos manipular dados e texto linha a linha, permitindo a pesquisa, formata\u00e7\u00e3o e c\u00e1lculos, entre outros. \u00c9 especialmente \u00fatil para trabalhar com ficheiros estruturados, como <code>.csv</code>.</p> <p>A sua sintaxe geral \u00e9 a seguinte:</p> <pre><code>awk 'condi\u00e7\u00e3o {a\u00e7\u00e3o}' ficheiro\n</code></pre> <ul> <li><code>condi\u00e7\u00e3o</code> \u2192  Define a condi\u00e7\u00e3o que, se for verdadeira, executa a a\u00e7\u00e3o</li> <li><code>a\u00e7\u00e3o</code> \u2192 O que fazer se condi\u00e7\u00e3o for verdadeira</li> </ul> <p>Exemplo <code>awk</code></p> <p><pre><code>awk '{print $1, $3}' ficheiro.txt\n</code></pre> O <code>awk</code> divide cada linha em campos, que s\u00e3o numerados a partir de <code>$1</code> (primeiro campo), <code>$2</code> (segundo campo) e assim por diante. No exemplo acima, se o <code>ficheiro.txt</code> for constitu\u00eddo por:</p> <pre><code>Jo\u00e3o 30 Lisboa\nMaria 25 Porto\nPedro 22 Coimbra\n</code></pre> <p>O comando <code>awk</code> produziria o resultado:</p> <pre><code>Jo\u00e3o Lisboa\nMaria Porto\nPedro Coimbra\n</code></pre> <p>Nota - Delimitadores de campo: Por defeito, o <code>awk</code> usa espa\u00e7os ou tabs como delimitadores de campos, mas \u00e9 poss\u00edvel definir outro delimitador (e.g., <code>,</code> ou <code>;</code>) utilizando a op\u00e7\u00e3o <code>-F</code>. Por exemplo, se o arquivo estiver separado por v\u00edrgulas (e.g., <code>.csv</code>), podemos fazer:</p> <pre><code>awk -F, '{print $1, $2}' ficheiro.csv\n</code></pre>"},{"location":"lab03/awk/#outras-operacoes-com-o-awk","title":"Outras opera\u00e7\u00f5es com o <code>awk</code>","text":"<p>Filtragem com condi\u00e7\u00f5es</p> <p>\u00c9 possivel usar o <code>awk</code> para imprimir apenas as linhas que atendam a um determinado crit\u00e9rio. Por exemplo, para imprimir as linhas onde o valor do primeiro campo \u00e9 <code>\"Maria\"</code>: <pre><code>awk '$1 == \"Maria\" {print}' ficheiro.txt\n</code></pre></p> <p>Neste, caso a sa\u00edda seria: <pre><code>Maria 25 Porto\n</code></pre></p> <p>Somar valores de uma coluna</p> <p>O <code>awk</code> tamb\u00e9m pode ser usado para realizar opera\u00e7\u00f5es matem\u00e1ticas. Por exemplo: <pre><code>awk '{soma += $2} END {print soma}' ficheiro.txt\n</code></pre> Este comando soma os valores na segunda coluna e imprime o resultado, neste caso seria <code>77</code>. Aqui, <code>soma += $2</code> vai somando os valores da coluna 2 e a instru\u00e7\u00e3o <code>END {print soma}</code> imprime o total ap\u00f3s serem processadas todas as linhas.</p> <p>Combinar condi\u00e7\u00f5es</p> <p>Por exemplo, para imprimir as linhas em que o segundo campo (idade) seja maior que 20:</p> <pre><code>awk '$2 &gt; 20 {print}' ficheiro.txt\n</code></pre> <p>Usar vari\u00e1veis no <code>awk</code></p> <p>\u00c9 poss\u00edvel usar o <code>awk</code> para fazer c\u00e1lculos ou manipular valores, tal como calcular a m\u00e9dia de idades no ficheiro: <pre><code>awk '{soma += $2; count++} END {print soma/count}' ficheiro.txt\n</code></pre> Aqui, <code>count</code> conta o n\u00famero de linhas e soma acumula o valor do segundo campo (idade). A m\u00e9dia \u00e9 calculada na parte <code>END {print soma/count}</code>.</p>"},{"location":"lab03/awk/#begin-e-end-no-awk","title":"<code>BEGIN</code> e <code>END</code> no <code>awk</code>","text":"<p>O <code>awk</code> processa as linhas de um arquivo de texto linha a linha. A estrutura <code>BEGIN</code> e <code>END</code> permite-nos executar  c\u00f3digo antes ou depois de processar o ficheiro. Como vimos nos exemplos acima, n\u00e3o \u00e9 necess\u00e1rio usar o <code>BEGIN</code> se n\u00e3o precisarmos de algo a ser executado antes de processarmos o conte\u00fado do ficheiro. O <code>END</code> \u00e9 \u00fatil quando queremos executar algum c\u00f3digo ap\u00f3s o processamento de todas as linhas (por exemplo, imprimir a soma, uma contagem, etc.)</p> <p>O bloco <code>BEGIN</code> \u00e9 executado antes de o <code>awk</code> processar as linhas do ficheiro. \u00c9 \u00fatil quando queremos fazer configura\u00e7\u00f5es iniciais, como definir vari\u00e1veis ou imprimir algo:</p> <pre><code>awk 'BEGIN {print \"In\u00edcio do script\"} {print} END {print \"Fim do script\"}' ficheiro.txt\n</code></pre> <p>Este comando imprime a mensagem <code>\"In\u00edcio do script\"</code> antes de come\u00e7ar a processar as linhas do ficheiro. Em seguida, imprime todas as linhas do ficheiro com <code>{print}</code> e no final imprime a mensagem <code>\"Fim do script\"</code>, no final do processamento de todas as linhas.</p> <p>Por sua vez, o bloco <code>END</code> \u00e9 executado ap\u00f3s o processamento de todas as linhas e \u00e9 \u00fatil para realizar alguma a\u00e7\u00e3o final, como por exemplo, imprimir resultados agregados ou mensagens ap\u00f3s processar todas as linhas, como j\u00e1 vimos anteriormente:</p> <p><pre><code>awk 'BEGIN {print \"In\u00edcio do processamento\"} {print $1, $2} END {print \"Processamento completo\"}' ficheiro.txt\n</code></pre> Se n\u00e3o precisarmos de executar nada antes de processar as linhas, podemos omitir o bloco <code>BEGIN</code>. Em vez disso, basta ter a parte do <code>END</code> para realizar uma a\u00e7\u00e3o ap\u00f3s o processamento do ficheiro:</p> <pre><code>awk '{soma += $2} END {print \"Soma:\", soma}' ficheiro.txt\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel usar apenas o <code>BEGIN</code> para configura\u00e7\u00f5es ou inicializa\u00e7\u00f5es antes de come\u00e7ar o processamento de dados. Por exemplo, podemos definir o separador de campos como <code>,</code> e imprimir uma linha de cabe\u00e7alho:</p> <pre><code>awk 'BEGIN {FS=\",\"; print \"Cabe\u00e7alho: Nome, Idade, Cidade\"}'\n</code></pre>"},{"location":"lab03/awk/#variaveis-uteis-no-awk","title":"Vari\u00e1veis \u00fateis no <code>awk</code>","text":"<p>O <code>awk</code> trabalha com registos (linhas) e campos (colunas) e algumas vari\u00e1veis predefinidas facilitam o trabalho:</p> <ul> <li><code>FS</code>: Define o delimitador dos campos na entrada (por defeito usa o espa\u00e7o)</li> <li><code>OFS</code>: Define o delimitador entre campos na sa\u00edda (por defeito \u00e9 o espa\u00e7o)</li> <li><code>RS</code>: Define o separador de linhas na entrada (por defeito \u00e9 uma linha nova <code>\\n</code>)</li> <li><code>ORS</code>: Define o separador de linhas na sa\u00edda (por defeito \u00e9 uma linha nova <code>\\n</code>)</li> <li><code>NF</code>: N\u00famero de campos na linha atual</li> <li><code>NR</code>: N\u00famero total de linhas processados</li> <li><code>$0</code>: A linha inteira, e.g. <code>{print $0}</code> equivale a <code>{print}</code></li> <li><code>$1</code>, <code>$2</code>, ..., <code>$NF</code>: Campos individuais (por exemplo, <code>$1</code> \u00e9 o primeiro campo, <code>$2</code> \u00e9 o segundo, etc.)</li> <li><code>$NF</code>: O \u00faltimo campo da linha</li> </ul>"},{"location":"lab03/awk/#uso-avancado-do-awk","title":"Uso avan\u00e7ado do <code>awk</code>","text":"<p>O <code>awk</code> \u00e9 uma ferramenta poderosa, n\u00e3o s\u00f3 para processamento de texto simples, mas tamb\u00e9m para fazer opera\u00e7\u00f5es mais complexas como condicionais (<code>if-else</code>) e loops (e.g. <code>for</code>). Alguns exemplos encontram-se abaixo:</p> <pre><code>awk '{if ($2 &gt; 50) {print $1 \" \u00e9 maior que 50\"} else {print $1 \" \u00e9 menor ou igual a 50\"}}' ficheiro.txt\nawk 'BEGIN {for (i=1; i&lt;=5; i++) print \"Valor de i:\", i}' \nawk '{sum += $2} END {print \"Soma:\", sum; print \"M\u00e9dia:\", sum/NR}' ficheiro.txt\nawk '{if ($1 ~ /^J/) print $1 \" come\u00e7a com J\"}' ficheiro.txt\nawk '{if ($1 == \"Jo\u00e3o\" &amp;&amp; $2 &gt; 20) print $0; else if ($1 == \"Maria\" || $2 &lt; 25) print $0}' ficheiro.txt\n</code></pre>"},{"location":"lab03/ex03_01/","title":"Exerc\u00edcio 1","text":"<p>1. An\u00e1lise de Sequ\u00eancias de DNA</p> <p>Como explorou no Lab 28/02, as sequ\u00eancias de DNA analisadas s\u00e3o comummente representadas por quatro nucle\u00f3tidos: <code>A</code>, <code>C</code>, <code>T</code>, <code>G</code>. </p> <p>Nucle\u00f3tidos desconhecidos aparecem frequentemente representados pelo caractere <code>N</code>, indicando uma posi\u00e7\u00e3o onde o processo de sequencia\u00e7\u00e3o n\u00e3o conseguiu identificar  com confian\u00e7a o respetivo nucle\u00f3tido.</p> <p>Considere agora os ficheiros <code>.fastq</code> (pasta <code>MiSeq</code>) da aula anterior:</p> <ul> <li>Procure todas as ocorr\u00eancias que contenham segmentos de 10 nucle\u00f3tidos desconhecidos consecutivos (e.g., <code>NNNNNNNNNN</code>).</li> </ul> Resultado Esperado <pre><code>F3D0_S188_L001_R2_001.fastq:CCTGTTTGCTCCCCACGCTTTCGAGCCTCAACGTCAGTTACAGTCCAGCAAGCCGCCTTCGCCACTGGTGTTCCTCCTAATATCTACNCNTNNNNNNNNNNCACTAGGAATTCCACTTGCCTCTCCTGCACTCCAGCAGCACAGTTTCCAAAGCAGTCCGGGGGTTGGGCCCCCGCCTTTCACTTCAGACTTGCACTGCCGTCTACGCTCCCTTTACACCCAGTAAATCCGGATAACGCTTGCCCCCTACG\n(...) \n</code></pre> <ul> <li>Para al\u00e9m das sequ\u00eancias, escreva um comando que inclua tamb\u00e9m o identificador da sequ\u00eancia e as linhas do ficheiro onde o padr\u00e3o ocorre. Escreva o resultado para um ficheiro <code>bad_sequences.txt</code>.</li> <li>Use o comando <code>wc</code> para contar o n\u00famero de linhas do ficheiro <code>bad_sequences.txt</code>. O n\u00famero de linhas corresponde ao n\u00famero de sequ\u00eancias encontrado? Porqu\u00ea? </li> <li>Escreva um comando <code>grep</code> que consiga filtrar o artefacto <code>--</code>. Investigue o argumento <code>-v</code> e procure um padr\u00e3o regex adequado (use <code>^</code> para indicar o in\u00edcio de uma linha...)</li> <li>Use um commando <code>grep</code> para escrever apenas os ficheiros <code>.fastq</code> que cont\u00eam o padr\u00e3o <code>NNNNNNNNNN</code> para um ficheiro <code>bad_files.txt</code>. Em quantos ficheiros encontramos este padr\u00e3o?</li> </ul> Resultado Esperado <pre><code>26 files\n</code></pre> <ul> <li>No laborat\u00f3rio anterior, procurou sequ\u00eancias de nucle\u00f3tidos do tipo <code>ATG......</code> no ficheiro <code>phix.fa</code>. Considere agora o ficheiro <code>HMP_MOCK.v35.fasta</code>. Que sequ\u00eancias terminam exactamente em <code>GACC</code>?</li> </ul> Resultado Esperado <pre><code>&gt;E.faecalis.1\nTAGGGAATCTTCGGCAATGGACGAAAGTCTGACCGAGCAACGCCGCGTGAGTGAAGAAGGTTTTCGGATCGTAAAACTCTGTTGTTAGAGAAGAACAAGGACGTTAGTAACTGAACGTCCCCTGACGGTATCTAACCAGAAAGCCACGGCTAACTACGTGCCAGCAGCCGCGGTAATACGTAGGTGGCAAGCGTTGTCCGGATTTATTGGGCGTAAAGCGAGCGCAGGCGGTTTCTTAAGTCTGATGTGAAAGCCCCCGGCTCAACCGGGGAGGGTCATTGGAAACTGGGAGACTTGAGTGCAGAAGAGGAGAGTGGAATTCCATGTGTAGCGGTGAAATGCGTAGATATATGGAGGAACACCAGTGGCGAAGGCGGCTCTCTGGTCTGTAACTGACGCTGAGGCTCGAAAGCGTGGGGAGCAAACAGGATTAGATACCCTGGTAGTCCACGCCGTAAACGATGAGTGCTAAGTGTTGGAGGGTTTCCGCCCTTCAGTGCTGCAGCAAACGCATTAAGCACTCCGCCTGGGGAGTACGACC\n&gt;E.faecalis.2\nTAGGGAATCTTCGGCAATGGACGAAAGTCTGACCGAGCAACGCCGCGTGAGTGAAGAAGGTTTTCGGATCGTAAAACTCTGTTGTTAGAGAAGAACAAGGACGTTAGTAACTGAACGTCCCCTGACGGTATCTAACCAGAAAGCCACGGCTAACTACGTGCCAGCAGCCGCGGTAATACGTAGGTGGCAAGCGTTGTCCGGATTTATTGGGCGTAAAGCGAGCGCAGGCGGTTTCTTAAGTCTGATGTGAAAGCCCCCGGCTCAACCGGGGAGGGTCATTGGAAACTGGGAGACTTGAGTGCAGAAGAGGAGAGTGGAATTCCATGTGTAGCGGTGAAATGCGTAGATATATGGAGGAACACCAGTGGCGAAGGCGGCTCTCTGGTCTGTAACTGACGCTGAGGCTCGAAAGCGTGGGGAGCAAACAGGATTAGATACCCTGGTAGTCCACGCCGTAAACGATGAGTGCTAAGTGTTGGAGGGTTTCCGCCCTTCAGTGCTGCAGCAAACGCATTAAGCACTCCGCCTGGGGAGTACGACC\n(...) \n</code></pre> <ul> <li> <p>Em vez de imprimir o identificador e toda a sequ\u00eancia, complemente o comando criado na al\u00ednea anterior para obter apenas os identificadores: <pre><code>&gt;E.faecalis.1\n&gt;E.faecalis.2\n&gt;L.gasseri.1\n&gt;L.monocytogenes.1\n&gt;S.aureus.1\n&gt;S.aureus.5\n&gt;S.epidermidis.1\n&gt;S.epidermidis.2\n&gt;S.epidermidis.5\n&gt;S.agalactiae.1\n&gt;S.mutans.1\n&gt;S.pneumoniae.1\n</code></pre></p> </li> <li> <p>Partindo novamente do ficheiro <code>HMP_MOCK.v35.fasta</code>, imprima as sequ\u00eancias correspondentes apenas aos identificadores <code>vulgatus</code> ou <code>epidermidis</code> (consulte o comando <code>egrep</code>).</p> </li> </ul> Resultado Esperado <pre><code>&gt;B.vulgatus.1\nTGAGGAATATTGGTCAATGGGCGCAGGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTATGGGTTGTAAACTTCTTTTATAAAGGAATAAAGTCGGGTATGGATACCCGTTTGCATGTACTTTATGAATAAGGATCGGCTAACTCCGTGCCAGCAGCCGCGGTAATACGGAGGATCCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGAGCGTAGATGGATGTTTAAGTCAGTTGTGAAAGTTTGCGGCTCAACCGTAAAATTGCAGTTGATACTGGATATCTTGAGTGCAGTTGAGGCAGGCGGAATTCGTGGTGTAGCGGTGAAATGCTTAGATATCACGAAGAACTCCGATTGCGAAGGCAGCCTGCTAAGCTGCAACTGACATTGAGGCTCGAAAGTGTGGGTATCAAACAGGATTAGATACCCTGGTAGTCCACACGGTAAACGATGAATACTCGCTGTTTGCGATATACGGCAAGCGGCCAAGCGAAAGCGTTAAGTATTCCACCTGGGGAGTACGCCG\n(...)\n&gt;S.epidermidis.1\nTAGGGAATCTTCCGCAATGGGCGAAAGCCTGACGGAGCAACGCCGCGTGAGTGATGAAGGTCTTCGGATCGTAAAACTCTGTTATTAGGGAAGAACAAATGTGTAAGTAACTATGCACGTCTTGACGGTACCTAATCAGAAAGCCACGGCTAACTACGTGCCAGCAGCCGCGGTAATACGTAGGTGGCAAGCGTTATCCGGAATTATTGGGCGTAAAGCGCGCGTAGGCGGTTTTTTAAGTCTGATGTGAAAGCCCACGGCTCAACCGTGGAGGGTCATTGGAAACTGGAAAACTTGAGTGCAGAAGAGGAAAGTGGAATTCCATGTGTAGCGGTGAAATGCGCAGAGATATGGAGGAACACCAGTGGCGAAGGCGACTTTCTGGTCTGTAACTGACGCTGATGTGCGAAAGCGTGGGGATCAAACAGGATTAGATACCCTGGTAGTCCACGCCGTAAACGATGAGTGCTAAGTGTTAGGGGGTTTCCGCCCCTTAGTGCTGCAGCTAACGCATTAAGCACTCCGCCTGGGGAGTACGACC\n(...)\n</code></pre>"},{"location":"lab03/ex03_02/","title":"Exerc\u00edcio 2","text":"<p>2. Stream Editor (sed)</p> <p>Na ficha anterior, vimos como podemos examinar ficheiros com os comandos <code>cat</code> e <code>head</code> por exemplo. Adicionalmente, o comando <code>sed</code> (stream editor) permite-nos manipular caracteres de v\u00e1rias formas nos nossos dados e ficheiros. Algumas das a\u00e7\u00f5es mais \u00fateis s\u00e3o a extra\u00e7\u00e3o (print) de linhas espec\u00edficas nos nossos ficheiros e a substitui\u00e7\u00e3o de caracteres espec\u00edficos em ficheiros. </p> <p>macOS</p> <p>Se tiver problemas no macOS, pode ser melhor fazer primeiro <code>brew install gnu-sed</code> e usar <code>gsed</code> em vez de <code>sed</code>.</p> <ul> <li>Considere por exemplo o ficheiro <code>F3D0_S188_L001_R1_001.fastq</code>. Sabemos que podemos usar o <code>cat</code> para imprimir todo o conte\u00fado ou o <code>head</code> para investigar as primeiras <code>n</code> linhas. Para extrair linhas espec\u00edficas, podemos usar o <code>sed</code>. Procure um comando <code>sed</code> que imprima as linhas 5 a 8 do ficheiro.</li> </ul> Resultado Esperado <pre><code>@M00967:43:000000000-A3JHG:1:1101:14069:1827 1:N:0:188\nTACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGCCTGCCAAGTCAGCGGTAAAATTGCGGGGCTCAACCCCGTACAGCCGTTGAAACTGCCGGGCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACCCCGATTGCGAAGGCAGCATACCGGCGCCCTACTGACGCTGAGGCACGAAAGTGCGGGGATCAAACAG\n+\n3AA?ABBDBFFBEGGEGGGGAFFGGGGGHHHCGGGGGGHFGHGGCFDEFGGGHGGGEGF1GGFGHHHHHGGEGGHHHHHFGGGGGGHHHHHGGGGCDDGHHGGGFHHHHHHHHCD@CCHGGGGHEHGGG@GFGGGGGGG@BGGGEGCEBFFFBFFB;9@EFFFEFFFFFFFFFFFFAFBBBFFFFFBBBFFFFBBBFFFFFFFFFFFBBBBBBBFFFFFFFFFDDFAFFFFF.AF9/FBBBBB.EAFFE?F\n</code></pre> <ul> <li>Para al\u00e9m de um intervalo, \u00e9 poss\u00edvel tamb\u00e9m operar com a intercala\u00e7\u00e3o de linhas, atrav\u00e9s do operador <code>~</code>.  Procure um comando <code>sed</code> que lhe permita extrair apenas os header/ID das sequ\u00eancias do ficheiro <code>F3D0_S188_L001_R1_001.fastq</code>.</li> </ul> Resultado Esperado <pre><code>@M00967:43:000000000-A3JHG:1:1101:18327:1699 1:N:0:188\n@M00967:43:000000000-A3JHG:1:1101:18044:1900 1:N:0:188\n@M00967:43:000000000-A3JHG:1:1101:13234:1983 1:N:0:188\n(...)\n</code></pre> <ul> <li>Use a mesma l\u00f3gica para extrair apenas os IDs das sequ\u00eancias problem\u00e1ticas que encontrou no exerc\u00edcio anterior (<code>bad_sequences.txt</code>). Escreva um comando <code>sed</code> que retire apenas os IDs das sequ\u00eancias do ficheiro <code>bad_sequences.txt</code> e os escreva para <code>bad_sequences_id.txt</code>.</li> </ul> Resultado Esperado <pre><code>F3D0_S188_L001_R2_001.fastq-2137-@M00967:43:000000000-A3JHG:1:1102:12112:28322 2:N:0:188\nF3D0_S188_L001_R2_001.fastq-2997-@M00967:43:000000000-A3JHG:1:1103:25476:25068 2:N:0:188\nF3D0_S188_L001_R2_001.fastq-4005-@M00967:43:000000000-A3JHG:1:1104:15518:28940 2:N:0:188\n</code></pre> <ul> <li>Utilize o comando <code>sed</code> para extrair apenas as primeiras 3 sequ\u00eancias de nucle\u00f3tidos do ficheiro <code>F3D0_S188_L001_R1_001.fastq</code>. (Pode experimentar combinar com um pipe).</li> </ul> Resultado Esperado <pre><code>NACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGCCTGCCAAGTCAGCGGTAAAATTGCGGGGCTCAACCCCGTACAGCCGTTGAAACTGCCGGGCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACCCCGATTGCGAAGGCAGCATACCGGCGCCCTACTGACGCTGAGGCACGAAAGTGCGGGGATCAAACAG\nTACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGCCTGCCAAGTCAGCGGTAAAATTGCGGGGCTCAACCCCGTACAGCCGTTGAAACTGCCGGGCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACCCCGATTGCGAAGGCAGCATACCGGCGCCCTACTGACGCTGAGGCACGAAAGTGCGGGGATCAAACAG\nTACGGAGGATGCGAGCGTTGTCCGGAATCACTGGGCGTAAAGGGCGCGTAGGCGGTTTAATAAGTCAGTGGTGAAAACTGAGGGCTCAACCCTCAGCCTGCCACTGATACTGTTAGACTTGAGTATGGAAGAGGAGAATGGAATTCCTAGTGTAGCGGTGAAATGCGTAGATATTAGGAGGAACACCAGTGGCGAAGGCGATTCTCTGGGCCAAGACTGACGCTGAGGCGCGAAAGCGTGGGGAGCAAACA\n</code></pre> <ul> <li>Nas 3 sequ\u00eancias encontradas, escreva um comando <code>sed</code> que substitua todos os nucle\u00f3tidos <code>T</code> por <code>U</code> (combine o comando anterior com um novo pipe).</li> </ul> Resultado Esperado <pre><code>NACGGAGGAUGCGAGCGUUAUCCGGAUUUAUUGGGUUUAAAGGGUGCGUAGGCGGCCUGCCAAGUCAGCGGUAAAAUUGCGGGGCUCAACCCCGUACAGCCGUUGAAACUGCCGGGCUCGAGUGGGCGAGAAGUAUGCGGAAUGCGUGGUGUAGCGGUGAAAUGCAUAGAUAUCACGCAGAACCCCGAUUGCGAAGGCAGCAUACCGGCGCCCUACUGACGCUGAGGCACGAAAGUGCGGGGAUCAAACAG\nUACGGAGGAUGCGAGCGUUAUCCGGAUUUAUUGGGUUUAAAGGGUGCGUAGGCGGCCUGCCAAGUCAGCGGUAAAAUUGCGGGGCUCAACCCCGUACAGCCGUUGAAACUGCCGGGCUCGAGUGGGCGAGAAGUAUGCGGAAUGCGUGGUGUAGCGGUGAAAUGCAUAGAUAUCACGCAGAACCCCGAUUGCGAAGGCAGCAUACCGGCGCCCUACUGACGCUGAGGCACGAAAGUGCGGGGAUCAAACAG\nUACGGAGGAUGCGAGCGUUGUCCGGAAUCACUGGGCGUAAAGGGCGCGUAGGCGGUUUAAUAAGUCAGUGGUGAAAACUGAGGGCUCAACCCUCAGCCUGCCACUGAUACUGUUAGACUUGAGUAUGGAAGAGGAGAAUGGAAUUCCUAGUGUAGCGGUGAAAUGCGUAGAUAUUAGGAGGAACACCAGUGGCGAAGGCGAUUCUCUGGGCCAAGACUGACGCUGAGGCGCGAAAGCGUGGGGAGCAAACA\n</code></pre> <ul> <li> <p>Fa\u00e7a uma c\u00f3pia do ficheiro <code>F3D0_S188_L001_R1_001.fastq</code>. Agora, substitua no pr\u00f3prio ficheiro todos os nucle\u00f3tidos <code>T</code> por <code>U</code>.</p> </li> <li> <p>Use o <code>sed</code> agora em todas as sequ\u00eancias do ficheiro <code>F3D0_S188_L001_R1_001.fastq</code> (do ficheiro original), combinando com um comando <code>grep</code> para extrair todos os nucle\u00f3tidos, um por linha (investigue o argumento <code>-o</code> .).</p> </li> <li> <p>A partir do comando anterior, escreva um comando que fa\u00e7a a contagem de nucle\u00f3tidos do ficheiro <code>F3D0_S188_L001_R1_001.fastq</code>. </p> </li> </ul> Resultado Esperado <pre><code>79970 A\n62340 C\n61992 T\n09427 G\n    5 N\n</code></pre>"},{"location":"lab03/ex03_03/","title":"Exerc\u00edcio 3","text":"<p>3. Awk</p> <p>Para explorar as funcionalidades do awk, considere o ficheiro ecoli.csv.</p> <ul> <li> <p>Imprima apenas as colunas <code>sample</code> e <code>genome_size</code>.</p> </li> <li> <p>Imprima as linhas em que a <code>generation</code> \u00e9 superior a 31000.</p> </li> <li> <p>Calcule a soma do <code>genome_size</code> considerando todas as amostras (linhas).</p> </li> </ul> Resultado Esperado <pre><code>Sum of genome_size: 139.88\n</code></pre> <ul> <li>Calcule a m\u00e9dia do <code>genome_size</code> para todas as amostras.</li> </ul> Resultado Esperado <pre><code>Average of genome_size for all samples: 4.66267\n</code></pre> <ul> <li>Calcule a m\u00e9dia do <code>genome_size</code> para as amostras cuja <code>generation</code> est\u00e1 entre 20000 e 30000 inclusive.</li> </ul> Resultado Esperado <pre><code>Average of genome_size for generation 20000-30000: 4.61857\n</code></pre> <ul> <li> <p>Imprima apenas as amostras em que a <code>clade</code> \u00e9 <code>Cit+</code>.</p> </li> <li> <p>Imprima as amostras em que o <code>cit</code> \u00e9 diferente de <code>unknown</code> e o <code>clade</code> \u00e9 <code>C1</code> ou <code>C2</code>.</p> </li> <li> <p>Imprima o nome das amostras em que o <code>genome_size</code> \u00e9 superior a 4.7, caso contr\u00e1rio imprima <code>Low</code>.</p> </li> <li> <p>Conte o n\u00famero de amostras com o <code>genome_size</code> entre 4.6 e 4.7.</p> </li> </ul> Resultado Esperado <pre><code>Number of samples with genome size between 4.6 and 4.7: 18\n</code></pre> <ul> <li>Verifique se alguma amostra tem um <code>genome_size</code>inferior a 4.6 e se sim, imprima a mensagem <code>Warning: Genome Size = {genome_size} for sample {sample}</code>.</li> </ul> Resultado Esperado <pre><code>Warning: Genome Size = 4.59 for sample ZDB429\nWarning: Genome Size = 4.59 for sample ZDB483\nWarning: Genome Size = 4.59 for sample CZB199\n</code></pre> <ul> <li>Imprima todas as amostras com o <code>sample</code> a come\u00e7ar por <code>REL</code>.</li> </ul> Resultado Esperado <pre><code>REL606\nREL1166A\nREL10979\nREL10988\n</code></pre> <ul> <li>Conte o n\u00famero de ocorr\u00eancias de cada categoria de <code>clade</code>.</li> </ul> Resultado Esperado <pre><code>UC 2\nunknown 2\nC1 7\nC2 7\nC3 2\nNA 1\nCit+ 9\n</code></pre>"},{"location":"lab03/grep/","title":"O comando <code>grep</code>","text":"<p>O comando <code>grep</code> (Global Regular Expression Print), que j\u00e1 abord\u00e1mos no laborat\u00f3rio anterior, \u00e9 uma ferramenta muito \u00fatil do Unix/Linux utilizada para pesquisar padr\u00f5es de texto dentro de ficheiros ou fluxos de entrada.</p> <p>A sintaxe geral do <code>grep</code> \u00e9:</p> <pre><code>grep [op\u00e7\u00f5es] \"padr\u00e3o\" ficheiro\n</code></pre> <p>Exemplo <code>grep</code></p> <p>O comando seguinte procura a sequ\u00eancia <code>ATCG</code> dentro do ficheiro <code>sequencias.txt</code> e imprime as linhas onde essa sequ\u00eancia aparece: <pre><code>grep \"ATCG\" sequencias.txt\n</code></pre></p>"},{"location":"lab03/grep/#opcoes-uteis-do-grep","title":"Op\u00e7\u00f5es \u00fateis do <code>grep</code>","text":"<ul> <li><code>-i</code> \u2192 Ignora diferen\u00e7as entre mai\u00fasculas e min\u00fasculas.</li> <li><code>-v</code> \u2192 Mostra as linhas que N\u00c3O correspondem ao padr\u00e3o.</li> <li><code>-c</code> \u2192 Conta o n\u00famero de ocorr\u00eancias.</li> <li><code>-n</code> \u2192 Mostra os n\u00fameros das linhas onde h\u00e1 correspond\u00eancias.</li> <li><code>-o</code> \u2192 Exibe apenas as partes da linha que correspondem ao padr\u00e3o.</li> <li><code>-r</code> ou <code>-R</code> \u2192 Pesquisa recursivamente em diretorias.</li> <li><code>-l</code> \u2192 Lista apenas os ficheiros que cont\u00eam o padr\u00e3o.</li> <li><code>--color</code> \u2192 Destaca as correspond\u00eancias no output.</li> <li><code>-f</code> \u2192 Permite que os padr\u00f5es sejam lidos a partir de um ficheiro.</li> </ul> <p>Alguns exemplos s\u00e3o:</p> <pre><code>grep -i \"gene\" dados.txt                # Pesquisa \"gene\" ignorando mai\u00fasculas/min\u00fasculas\ngrep -v \"erro\" log.txt                  # Mostra as linhas que N\u00c3O cont\u00eam \"erro\"\ngrep -c \"AGCT\" sequencias.txt           # Conta quantas vezes \"AGCT\" aparece no ficheiro \"sequencias.txt\"\ngrep -n \"muta\u00e7\u00e3o\" relat\u00f3rio.txt         # Mostra as linhas onde \"muta\u00e7\u00e3o\" aparece no \"relat\u00f3rio.txt\"\ngrep -o \"A[TGC]G\" sequencias.txt        # Mostra apenas as correspond\u00eancias do padr\u00e3o \"A seguido de T/G/C seguido de G\"\ngrep -r \"prote\u00edna\" /home/user/dados     # Pesquisa \"prote\u00edna\" em todos os ficheiros dentro da pasta \"dados\"\n</code></pre>"},{"location":"lab03/grep/#expressoes-regulares","title":"Express\u00f5es Regulares","text":"<p>Para pesquisas mais avan\u00e7adas, o <code>grep</code> permite o uso de express\u00f5es regulares (regex):</p> <ul> <li><code>^padr\u00e3o</code> \u2192 Pesquisa linhas que come\u00e7am com \"padr\u00e3o\".</li> <li><code>padr\u00e3o$</code> \u2192 Pesquisa linhas que terminam com \"padr\u00e3o\".</li> <li><code>.</code> \u2192 Corresponde a qualquer caractere.</li> <li><code>[ATCG]</code> \u2192 Corresponde a qualquer um dos caracteres especificados.</li> <li><code>[^ATCG]</code> \u2192 Corresponde a qualquer caractere que n\u00e3o seja um dos especificados.</li> <li><code>padr\u00e3o1\\|padr\u00e3o2</code> \u2192 Corresponde a \"padr\u00e3o1\" ou \"padr\u00e3o2\".</li> </ul> <p>Alguns exemplos:</p> <pre><code>grep \"^ATG\" sequencias.txt      # Encontra linhas que come\u00e7am com \"ATG\"\ngrep \"GTC$\" sequencias.txt      # Encontra linhas que terminam com \"GTC\"\ngrep \"A.G\" sequencias.txt       # Encontra \"A\" seguido de qualquer caractere e depois \"G\"\ngrep \"A[TC]G\" sequencias.txt    # Encontra \"A\" seguido de \"T\" ou \"C\" e depois \"G\"\ngrep \"AG\\|CT\" sequencias.txt    # Encontra linhas que cont\u00eam \"AG\" ou \"CT\"\n</code></pre>"},{"location":"lab03/grep/#outras-utilizacoes-do-grep","title":"Outras utiliza\u00e7\u00f5es do <code>grep</code>","text":"<p>O <code>grep</code> pode ser usado para pesquisar um padr\u00e3o em v\u00e1rios ficheiros ao mesmo tempo:</p> <pre><code>grep \"muta\u00e7\u00e3o\" ficheiro1.txt ficheiro2.txt\n</code></pre> <p>Pode ser combinado com outros comandos atrav\u00e9s de pipes (<code>|</code>): <pre><code>cat sequencias.txt | grep \"ATG\"\n</code></pre></p> <pre><code>ls -l | grep \".txt\"  # Lista apenas ficheiros .txt\n</code></pre> <p>Existem outras varia\u00e7\u00f5es do <code>grep</code> para diferentes tipos de ficheiros. Uma muito \u00fatil \u00e9 o <code>egrep</code> (Extended Grep), que suporta express\u00f5es regulares mais avan\u00e7adas. Tem a mesma fun\u00e7\u00e3o que o <code>grep -E</code>:</p> <p><code>grep</code>, <code>grep -E</code> e <code>egrep</code></p> <p><pre><code>grep \"ATG\\|TGA\" sequencias.txt  # Encontra linhas com \"ATG\" ou \"TGA\"\ngrep \"A\\{2,4\\}\" sequencias.txt  # Encontra \"AA\", \"AAA\" ou \"AAAA\"\n</code></pre> Neste caso \u00e9 necess\u00e1ria a barra <code>\\</code> (escape) para lidar com caracteres especiais (como <code>+</code>, <code>?</code>, <code>|</code>, <code>{}</code>).</p> <p><pre><code>egrep \"ATG|TGA\" sequencias.txt      # Equivalente a grep \"ATG\\|TGA\"\ngrep -E \"ATG|TGA\" sequencias.txt    # Mesmo comportamento do egrep\n\negrep \"A{2,4}\" sequencias.txt       # Encontra \"AA\", \"AAA\" ou \"AAAA\"\ngrep -E \"A{2,4}\" sequencias.txt     # Mesmo comportamento do egrep\n</code></pre> O <code>egrep</code> ou <code>grep -E</code> permite o uso direto de operadores como <code>+</code>, <code>?</code>, <code>|</code> e <code>{}</code>.</p>"},{"location":"lab03/intro/","title":"Introdu\u00e7\u00e3o ao Shell Scripting","text":"<p>Shell Scripting (i.e., \"programa\u00e7\u00e3o na shell\") \u00e9 uma forma alternativa de interagir com o sistema operativo atrav\u00e9s da shell. Em vez de inserir os comandos um a um, \u00e9 poss\u00edvel escrev\u00ea-los em scripts, que ser\u00e3o interpretados sequencialmente. O Shell scripting inclui os conceitos b\u00e1sicos de programa\u00e7\u00e3o como vari\u00e1veis, estruturas de controlo (condi\u00e7\u00f5es e loops) e fun\u00e7\u00f5es, permitindo-nos automatizar certas tarefas na shell. </p> <p>Bash Shell</p> <p>Diferentes shells (e.g. bash, sh, zsh, ...) podem apresentar varia\u00e7\u00f5es de sintaxe. Nos Laborat\u00f3rios de Bioinform\u00e1tica, vamos focar-nos mais na bash shell.</p>"},{"location":"lab03/intro/#conceitos-basicos","title":"Conceitos B\u00e1sicos","text":""},{"location":"lab03/intro/#extensao-e-binbash","title":"Extens\u00e3o e <code>!/bin/bash</code>","text":"<p>Os scripts de shell s\u00e3o frequentemente ficheiros com a extens\u00e3o .sh e para serem interpretados, precisam de permiss\u00f5es de execu\u00e7\u00e3o e leitura. Estas permiss\u00f5es podem ser adicionadas com o comando <code>chmod</code>, como no exemplo:  </p> <pre><code>chmod a+rx &lt;ficheiro_do_script&gt;\n</code></pre> <p>Como diferentes shells podem ter diferen\u00e7as na sintaxe, a primeira linha de qualquer script \u00e9 um coment\u00e1rio especial que indica o shell \"alvo\" (i.e., onde o script deve ser executado). Para a bash shell, essa primeira linha deve ser:  </p> <pre><code>#!/bin/bash\n</code></pre> <p>O s\u00edmbolo # pode depois ser utilizado para inserir coment\u00e1rios em qualquer linha.  </p>"},{"location":"lab03/intro/#variaveis","title":"Vari\u00e1veis","text":"<p>As vari\u00e1veis podem ser \u00fateis para armazenar informa\u00e7\u00f5es que ser\u00e3o necess\u00e1rias em etapas posteriores do script. A sintaxe para definir vari\u00e1veis \u00e9 a seguinte:  </p> <pre><code>&lt;vari\u00e1vel&gt;=&lt;valor&gt;\n</code></pre> <p>Nota que n\u00e3o devem existir espa\u00e7os antes ou depois do sinal <code>=</code>, pois, caso contr\u00e1rio, a shell interpretar\u00e1 o nome da vari\u00e1vel como um comando. Outro aspeto importante \u00e9 que o tipo da vari\u00e1vel n\u00e3o \u00e9 definido, ou seja, a shell armazena todas as vari\u00e1veis como strings, mas distingue dados textuais de dados num\u00e9ricos.  </p> <p>Para aceder ao valor de uma vari\u00e1vel, deve-se preceder o seu nome com <code>$</code>, como no exemplo:  </p> <pre><code>$&lt;vari\u00e1vel&gt;\n</code></pre> <p>Este s\u00edmbolo <code>$</code> tamb\u00e9m \u00e9 utilizado para aceder \u00e0s informa\u00e7\u00f5es sobre os argumentos passados ao script, nomeadamente:  </p> <ul> <li><code>$0</code> a <code>$9</code> \u2013 Acede a cada argumento individualmente;  </li> <li><code>$*</code> \u2013 Acede a todos os argumentos de uma vez;  </li> <li><code>$#</code> \u2013 Obt\u00e9m o n\u00famero total de argumentos passados.  </li> </ul>"},{"location":"lab03/intro/#exemplos","title":"Exemplos","text":"<p>Definir e usar vari\u00e1veis</p> <p>Criamos as vari\u00e1veis <code>nome</code> e <code>idade</code> com valores <code>Miriam</code> e <code>99</code>: <pre><code>nome=\"Miriam\"\nidade=99\necho \"O meu nome \u00e9 $nome e tenho $idade anos.\"\n</code></pre></p> <p>Usamos a sintaxe <code>$nome</code> e <code>$idade</code> para aceder aos valores:</p> <pre><code>O meu nome \u00e9 Miriam e tenho 99 anos.\n</code></pre> <p>Se houver espa\u00e7os antes ou depois do <code>=</code>, \u00e9 devolvido um erro: <pre><code>nome = Miriam       # Erro!\n</code></pre></p> <p>Aceder aos argumentos passados ao script</p> <p>Se criarmos um ficheiro <code>script.sh</code> com este conte\u00fado: <pre><code>#!/bin/bash\necho \"Nome do script: $0\"\necho \"Primeiro argumento: $1\"\necho \"Segundo argumento: $2\"\necho \"Todos os argumentos: $*\"\necho \"N\u00famero total de argumentos: $#\"\n</code></pre> E executarmos o script passando argumentos: <pre><code>./ script.sh Ana 30\n</code></pre></p> <p>O output esperado ser\u00e1:</p> <pre><code>Nome do script: script.sh\nPrimeiro argumento: Ana\nSegundo argumento: 30\nTodos os argumentos: Ana 30\nN\u00famero total de argumentos: 2\n</code></pre>"},{"location":"lab03/intro/#estruturas-de-controlo","title":"Estruturas de Controlo","text":""},{"location":"lab03/intro/#condicoes-if-elif-else","title":"Condi\u00e7\u00f5es (<code>if-elif-else</code>)","text":"<p>As estruturas condicionais permitem-nos tomar decis\u00f5es com base em testes ou condi\u00e7\u00f5es. A sintaxe b\u00e1sica \u00e9 a seguinte:</p> <p><pre><code>if &lt;condi\u00e7\u00e3o&gt;; then\n    # Comandos a executar se a condi\u00e7\u00e3o for verdadeira\nelif &lt;outra_condi\u00e7\u00e3o&gt;; then\n    # Comandos a executar se a outra condi\u00e7\u00e3o for verdadeira\nelse\n    # Comandos a executar se nenhuma das condi\u00e7\u00f5es anteriores for verdadeira\nfi\n</code></pre> Em rela\u00e7\u00e3o a esta condi\u00e7\u00e3o, os seguintes tipos s\u00e3o aceites:</p> <ul> <li> <p>Compara\u00e7\u00f5es com vari\u00e1veis num\u00e9ricas, strings ou ficheiros, que s\u00e3o definidas dentro de <code>[ ... ]</code>:</p> <p>Compara\u00e7\u00e3o num\u00e9rica</p> <pre><code>#!/bin/bash\n\na=10\nb=5\n\nif [ $a -gt $b ]; then\n    echo \"$a \u00e9 maior que $b\"\nelse\n    echo \"$a n\u00e3o \u00e9 maior que $b\"\nfi\n</code></pre> <p>Nota: <code>-gt</code> (greater than) \u00e9 usado para verificar se <code>a</code> \u00e9 maior que <code>b</code>.</p> <p>Compara\u00e7\u00e3o de strings</p> <p><pre><code>#!/bin/bash\n\nnome1=\"Jo\u00e3o\"\nnome2=\"Ana\"\n\nif [ \"$nome1\" = \"$nome2\" ]; then\n    echo \"Os nomes s\u00e3o iguais\"\nelse\n    echo \"Os nomes s\u00e3o diferentes\"\nfi\n</code></pre> Nota: Usamos <code>=</code> para verificar se as strings s\u00e3o iguais.</p> <p>Compara\u00e7\u00e3o de ficheiros</p> <p><pre><code>#!/bin/bash\n\nficheiro=\"/caminho/para/ficheiro.txt\"\n\nif [ -f \"$ficheiro\" ]; then\n    echo \"$ficheiro \u00e9 um ficheiro regular\"\nelse\n    echo \"$ficheiro n\u00e3o \u00e9 um ficheiro regular\"\nfi\n</code></pre> Nota: <code>-f</code> \u00e9 usado para verificar se o ficheiro fornecido \u00e9 um ficheiro regular.</p> </li> <li> <p>Execu\u00e7\u00e3o de comandos numa subshell, onde a condi\u00e7\u00e3o \u00e9 baseada no c\u00f3digo de sa\u00edda dos comandos, que s\u00e3o definidos dentro de <code>(...)</code>.</p> <p>Execu\u00e7\u00e3o de comandos numa subshell</p> <pre><code>#!/bin/bash\n\n# Verificar se o comando 'ls' foi bem-sucedido\nif ( ls /diretorio/nao/existe ); then\n    echo \"Comando executado com sucesso\"\nelse\n    echo \"Comando falhou\"\nfi\n</code></pre> <p>Nota: O comando <code>ls</code> est\u00e1 dentro de uma subshell <code>( ... )</code>. O c\u00f3digo de sa\u00edda do comando <code>ls</code> \u00e9 verificado. Como a diretoria n\u00e3o existe, a condi\u00e7\u00e3o falha e a cl\u00e1usula <code>else</code> ser\u00e1 executada.</p> </li> <li> <p>Opera\u00e7\u00f5es aritm\u00e9ticas, que s\u00e3o definidas dentro de <code>((...))</code>.</p> <p>Opera\u00e7\u00f5es aritm\u00e9ticas</p> <pre><code>#!/bin/bash\n\nx=5\ny=10\n\nif (( x + y &gt; 10 )); then\n    echo \"A soma de x e y \u00e9 maior que 10\"\nelse\n    echo \"A soma de x e y n\u00e3o \u00e9 maior que 10\"\nfi    \n</code></pre> </li> <li> <p>Compara\u00e7\u00f5es mais complexas, baseadas nas mencionadas no primeiro ponto, como verificar se uma string corresponde a uma express\u00e3o regular, que s\u00e3o definidas dentro de <code>[[ \u2026 ]]</code>.</p> <p>Opera\u00e7\u00f5es complexas (e.g., regex)</p> <p>Um exemplo de uma opera\u00e7\u00e3o mais complexa seria fazer compara\u00e7\u00f5es com express\u00f5es regulares (i.e., regex):</p> <pre><code>#!/bin/bash\n\nnome=\"Jo\u00e3o123\"\n\nif [[ $nome =~ ^Jo\u00e3o[0-9]+$ ]]; then\n    echo \"A string segue o padr\u00e3o\"\nelse\n    echo \"A string n\u00e3o segue o padr\u00e3o\"\nfi\n</code></pre> <p>Nota: Neste exemplo, usamos <code>[[...]]</code> para incorporar a express\u00e3o regular. O operador <code>=~</code> permite comparar uma string com uma express\u00e3o regular; neste caso, queremos verificar se a vari\u00e1vel <code>nome</code> come\u00e7a com \"Jo\u00e3o\" e tem n\u00fameros no final (<code>[0-9]+</code>), ou seja qualquer n\u00famero entre 0 e 9; <code>+</code> indica que pode haver um ou mais d\u00edgitos consecutivos.</p> </li> </ul> <p>Espa\u00e7os entre <code>[</code>e <code>]</code></p> <p>\u00c9 importante usar correctamente os espa\u00e7os ao usar <code>[</code>e <code>]</code> no bash. A raz\u00e3o \u00e9 que <code>[</code> \u00e9, na verdade, um comando (uma forma alternativa do comando <code>test</code>) e no Bash, os comandos e os seus argumentos devem ser separados por espa\u00e7os.</p> <pre><code>while [$contador -le 5]  # Erro: sem espa\u00e7os ao redor de [ e ]\nwhile [ $contador -le 5 ]  # OK: Espa\u00e7os corretos\n</code></pre> <p>Podemos testar com <code>test</code> diretamente: <pre><code>test 5 -le 10 &amp;&amp; echo \"Verdadeiro\"  # OK\ntest5 -le 10 &amp;&amp; echo \"Verdadeiro\"   # Erro: `test5` n\u00e3o \u00e9 um comando\n</code></pre></p> <p>O mesmo vale para <code>[</code>: <pre><code>[ 5 -le 10 ] &amp;&amp; echo \"Verdadeiro\"  # OK\n[5 -le 10] &amp;&amp; echo \"Verdadeiro\"    # Erro\n</code></pre></p>"},{"location":"lab03/intro/#operadores-de-comparacao-na-shell","title":"Operadores de Compara\u00e7\u00e3o na Shell","text":"<p>Para realizar as compara\u00e7\u00f5es com vari\u00e1veis num\u00e9ricas, strings e ficheiros, s\u00e3o necess\u00e1rios diferentes operadores.</p>"},{"location":"lab03/intro/#operadores-numericos","title":"Operadores Num\u00e9ricos","text":"<p>No caso dos tipos num\u00e9ricos, o operador \u00e9 definido entre dois valores ou vari\u00e1veis, como: <code>&lt;num1&gt; &lt;op&gt; &lt;num2&gt;</code>. Os operadores dispon\u00edveis s\u00e3o:</p> <ul> <li><code>-eq</code> \u2013 igual</li> <li><code>-ne</code> \u2013 diferente</li> <li><code>-lt</code> \u2013 menor que</li> <li><code>-le</code> \u2013 menor ou igual a</li> <li><code>-gt</code> \u2013 maior que</li> <li><code>-ge</code> \u2013 maior ou igual a</li> </ul> <p>Os operadores \"tradicionais\" (por exemplo, <code>&lt;</code> ou <code>&gt;</code>) s\u00f3 podem ser usados dentro de <code>((\u2026))</code>. </p>"},{"location":"lab03/intro/#operadores-de-strings","title":"Operadores de Strings","text":"<p>No caso das strings, o operador \u00e9 definido da mesma forma que para os tipos num\u00e9ricos e os operadores dispon\u00edveis s\u00e3o:</p> <ul> <li><code>=</code> \u2013 igual</li> <li><code>!=</code> \u2013 diferente</li> <li><code>-n</code> \u2013 a string n\u00e3o \u00e9 nula</li> <li><code>-z</code> \u2013 a string \u00e9 nula</li> </ul>"},{"location":"lab03/intro/#operadores-de-ficheiros","title":"Operadores de Ficheiros","text":"<p>Os operadores de ficheiros s\u00e3o definidos antes do caminho para um ficheiro espec\u00edfico, como: <code>&lt;op&gt; &lt;file&gt;</code>. Alguns dos operadores dispon\u00edveis s\u00e3o:</p> <ul> <li><code>-e</code> \u2013 existe</li> <li><code>-f</code> \u2013 \u00e9 um ficheiro regular (n\u00e3o um diretoria)</li> <li><code>-d</code> \u2013 \u00e9 uma diretoria</li> <li><code>-r</code> \u2013 tem permiss\u00f5es de leitura</li> <li><code>-w</code> \u2013 tem permiss\u00f5es de escrita</li> <li><code>-x</code> \u2013 tem permiss\u00f5es de execu\u00e7\u00e3o</li> </ul>"},{"location":"lab03/intro/#loops-for-while","title":"Loops (<code>for</code>, <code>while</code>)","text":"<p>O Shell Scripting suporta os comandos <code>for</code> e <code>while</code>. </p>"},{"location":"lab03/intro/#loop-for","title":"Loop <code>for</code>","text":"<p>O loop <code>for</code> \u00e9 utilizado para repetir um conjunto de comandos um determinado n\u00famero de vezes, geralmente iterando sobre uma lista ou intervalo.</p> <pre><code>for &lt;vari\u00e1vel&gt; in &lt;lista&gt;\ndo\n    # Comandos a executar para cada item da lista\ndone\n</code></pre> <p>Loop <code>for</code></p> <pre><code>#!/bin/bash\n\nfor i in 1 2 3 4 5\ndo\n    echo \"N\u00famero $i\"\ndone\n</code></pre> <p>Sa\u00edda: <pre><code>N\u00famero 1\nN\u00famero 2\nN\u00famero 3\nN\u00famero 4\nN\u00famero 5\n</code></pre></p> <p>Loop <code>for</code> com intervalo</p> <p><pre><code>#!/bin/bash\n\nfor i in {1..5}\ndo\n    echo \"N\u00famero $i\"\ndone\n</code></pre> Sa\u00edda: <pre><code>N\u00famero 1\nN\u00famero 2\nN\u00famero 3\nN\u00famero 4\nN\u00famero 5\n</code></pre></p> <p>Loop <code>for</code> com lista de valores</p> <p><pre><code>#!/bin/bash\n\nfor i in Alice Bob Carlos \"Diana Silva\" 42\ndo\n    echo $i\ndone\n</code></pre> Sa\u00edda: <pre><code>Alice\nBob\nDiana Silva\n42\n</code></pre></p> <p>Tamb\u00e9m existe a sintaxe mais \"tradicional\", onde a vari\u00e1vel \u00e9 incrementada entre um valor inicial e um valor final:</p> <pre><code>for ((exp1; exp2; exp3))\ndo\n    # Comandos a executar em cada itera\u00e7\u00e3o\ndone\n</code></pre> <p>Loop <code>for</code> com intervalo</p> <p><pre><code>#!/bin/bash\nfor ((i = 1; i &lt;= 5; i++))  # Inicia em 1, vai at\u00e9 5, incrementando 1 a cada itera\u00e7\u00e3o\ndo\n    echo \"N\u00famero: $i\"\ndone\n</code></pre> Sa\u00edda: <pre><code>N\u00famero 1\nN\u00famero 2\nN\u00famero 3\nN\u00famero 4\nN\u00famero 5\n</code></pre></p>"},{"location":"lab03/intro/#loop-while","title":"Loop <code>while</code>","text":"<p>O loop <code>while</code> executa um conjunto de comandos enquanto uma condi\u00e7\u00e3o for verdadeira:</p> <pre><code>while [ condi\u00e7\u00e3o ]\ndo\n    # Comandos a executar enquanto a condi\u00e7\u00e3o for verdadeira\ndone\n</code></pre> <p>Loop <code>while</code></p> <p><pre><code>#!/bin/bash\n\ncontador=1\n\nwhile [ $contador -le 5 ]\ndo\n    echo \"Contador: $contador\"\n    contador=$((contador + 1))  # Incrementa o contador\ndone\n</code></pre> Sa\u00edda: <pre><code>Contador: 1\nContador: 2\nContador: 3\nContador: 4\nContador: 5\n</code></pre></p>"},{"location":"lab03/intro/#subshells","title":"Subshells","text":"<p>Por vezes, temos interesse em executar comandos em subshells (i.e., \"processos filhos\" do processo atual) para obter o output de determinados comandos da mesma forma que \"chamamos\" uma fun\u00e7\u00e3o. Essa execu\u00e7\u00e3o pode ser feita definindo os comandos dentro de <code>$(...)</code>.</p> <p>Por exemplo, o output the um comando pode ser guardado numa vari\u00e1vel no formato:</p> <pre><code>&lt;vari\u00e1vel&gt;=$(&lt;comando&gt;)\n</code></pre>"},{"location":"lab03/intro/#leitura-e-escrita-na-shell","title":"Leitura e Escrita na Shell","text":"<p>O Shell Scripting tamb\u00e9m oferece alguns comandos que permitem a intera\u00e7\u00e3o com o utilizador, atrav\u00e9s do <code>echo</code> e <code>read</code>.</p> <p>Para escrever algo na shell, utiliza-se o comando <code>echo</code>. O comando <code>echo</code> recebe uma string e escreve-a na consola; se essa string contiver vari\u00e1veis previamente definidas, esses valores s\u00e3o apresentados:</p> <p>echo</p> <p><pre><code>#!/bin/bash\n\n# Definir a vari\u00e1vel\nNOME=\"Miriam\"\n\n# Exibir uma mensagem com a vari\u00e1vel\necho \"O meu nome \u00e9 $NOME\"\n</code></pre> Sa\u00edda: <pre><code>O meu nome \u00e9 Miriam\n</code></pre></p> <p>Para pedir informa\u00e7\u00f5es ao utilizador atrav\u00e9s da shell, o comando <code>read</code> pode ser usado, seguido pelo nome da vari\u00e1vel que vai armazenar a string inserida, como: <code>read &lt;vari\u00e1vel&gt;</code>. Esta vari\u00e1vel n\u00e3o precisa de ser declarada previamente.</p> <p>read</p> <p><pre><code>#!/bin/bash\n\n# Perguntar ao utilizador pelo nome\necho \"Qual \u00e9 o teu nome?\"\n\n# Ler a resposta e armazen\u00e1-la na vari\u00e1vel NOME\nread NOME\n\n# Exibir a mensagem com o nome inserido\necho \"Ol\u00e1, $NOME!\"\n</code></pre> Sa\u00edda: <pre><code>Qual \u00e9 o teu nome?\nMiriam\nOl\u00e1, Miriam\n</code></pre></p>"},{"location":"lab03/sed/","title":"O comando <code>sed</code>","text":"<p>O <code>sed</code> (stream editor) \u00e9 um comando muito \u00fatil para processamento de texto. O <code>sed</code> permite-nos ler os dados de um ficheiro ou a partir da entrada padr\u00e3o (stdin), modific\u00e1-los conforme as instru\u00e7\u00f5es fornecidas e enviar o resultado para a sa\u00edda padr\u00e3o (stdout). \u00c9 ideal para manipular ficheiros grandes, automatizar tarefas repetitivas e integrar pipelines de an\u00e1lise de dados.</p> <p>A sua sintaxe geral \u00e9 a seguinte:</p> <pre><code>sed [op\u00e7\u00f5es] 'script' ficheiro\n</code></pre> <p>Exemplo <code>sed</code></p> <p><pre><code>echo \"Ol\u00e1, Mundo!\" | sed 's/Mundo/Terra/'\n</code></pre> Neste exemplo, o comando <code>echo \"Ol\u00e1 Mundo!</code> imprime a string <code>\"Ol\u00e1, Mundo!\"</code>. Com o pipe, \u00e9 aplicado o comando <code>sed 's/Mundo/Terra/'</code> que substitui a palavra <code>\"Mundo\"</code> por <code>\"Terra\"</code>. A sa\u00edda final ser\u00e1: <code>Ol\u00e1, Terra!</code></p> <p>No caso, o script <code>s/Mundo/Terra/</code> \u00e9 uma express\u00e3o de substitui\u00e7\u00e3o onde <code>s</code> significa substitui\u00e7\u00e3o, <code>Mundo</code> \u00e9 o texto a ser substitu\u00eddo e <code>Terra</code> \u00e9 o novo texto.</p>"},{"location":"lab03/sed/#opcoes-uteis-do-sed","title":"Op\u00e7\u00f5es \u00fateis do <code>sed</code>","text":"<ul> <li><code>-e</code> \u2192 Permite especificar v\u00e1rios comandos diretamente na linha de comandos</li> <li><code>-f</code> \u2192 Permite aplicar os comandos definidos num ficheiro</li> <li><code>-i</code> \u2192 Edita diretamente o ficheiro de entrada</li> </ul> <p>Alguns exemplos s\u00e3o:</p> <pre><code>echo \"Ol\u00e1, Mundo!\" | sed -e 's/Mundo/Terra/' -e 's/Ol\u00e1/Oi/'    # Substitui \"Mundo\" por \"Terra\" e \"Ol\u00e1\" por \"Oi\"\necho \"Ol\u00e1, Mundo!\" | sed -f comandos.sed                       # Aplica os comandos definidos em \"comandos.sed\" (por exemplo, \"comandos.sed\" pode conter `s/Mundo/Terra/`)\nsed -i 's/Mundo/Terra/' texto.txt                              # Edita directamente o ficheiro texto.txt\n</code></pre>"},{"location":"lab03/sed/#substituicao-de-texto","title":"Substitui\u00e7\u00e3o de Texto","text":"<p>O <code>sed</code> \u00e9 amplamente usado para substituir texto dentro de ficheiros.</p> <p><pre><code>sed -e 's/antigo/novo/' ficheiro.txt\n</code></pre> Neste caso, substitui a primeira ocorr\u00eancia de \"antigo\" por \"novo\" em cada linha. Se uma linha tiver v\u00e1rias ocorr\u00eancias da palavra \"antigo\", apenas a primeira ser\u00e1 substitu\u00edda. Para substituir todas as ocorr\u00eancias podemos usar o comando:</p> <pre><code>sed -e 's/antigo/novo/g' ficheiro.txt\n</code></pre> <p>Por exemplo, podemos tamb\u00e9m usar o <code>sed</code> para converter todas as ocorr\u00eancias de <code>chr</code> em <code>CHR</code> num ficheiro .bed:</p> <pre><code>sed -e 's/chr/CHR/g' genes.bed\n</code></pre>"},{"location":"lab03/sed/#pesquisa-de-padroes","title":"Pesquisa de Padr\u00f5es","text":"<p>Tal como o <code>grep</code>, o <code>sed</code> pode ser usado para pesquisar e imprimir as linhas que cont\u00eam um padr\u00e3o. Por exemplo, para mostrar apenas as linhas que correspondem ao padr\u00e3o <code>\"Mundo\"</code> poder\u00edamos fazer:</p> <pre><code>sed -n '/Mundo/p' ficheiro.txt\n</code></pre> <ul> <li><code>-n</code> \u2192 Impede que o <code>sed</code> imprima todas as linhas, s\u00f3 ir\u00e1 imprimir as que forem especificadas</li> <li><code>/Mundo/</code> \u2192 A express\u00e3o regular que define o padr\u00e3o que queremos pesquisar</li> <li><code>p</code> \u2192 Instru\u00e7\u00e3o para imprimir as linhas que correspondem ao padr\u00e3o</li> </ul>"},{"location":"lab03/sed/#extracao-de-linhas","title":"Extra\u00e7\u00e3o de Linhas","text":"<p>Tamb\u00e9m podemos extrair linhas espec\u00edficas com o <code>sed</code>. Por exemplo, se quisermos extrair especificamente a linha 3 de um ficheiro, podemos usar o comando:</p> <pre><code>sed -n '3p' ficheiro.txt\n</code></pre> <ul> <li><code>-n</code> \u2192 Impede que o <code>sed</code> imprima todas as linhas</li> <li><code>'3p'</code> \u2192 Indica ao <code>sed</code> para imprimir (<code>p</code>) apenas a linha 3</li> </ul> <p>Para extrair um intervalo de linhas, por exemplo, da linha 2 \u00e0 linha 4, podemos usar:</p> <p><pre><code>sed -n '2,4p' ficheiro.txt\n</code></pre> Neste caso, <code>'2,4p'</code> indica ao <code>sed</code> para imprimir as linhas do intervalo de 2 a 4.</p> <p>Podemos ainda selecionar linhas com um intervalo regular. Por exemplo, a sintaxe <code>1~4p</code> no <code>sed</code> indica que devemos come\u00e7ar na linha 1 e em seguida, extrair a 4\u00aa linha depois dela. Genericamente, o formato <code>X~Yp</code> significa: come\u00e7ar na linha <code>X</code> e imprimir a cada <code>Y</code> linhas.</p> <p>Por exemplo:</p> <p><pre><code>sed -n '1~4p' ficheiro.txt\n</code></pre> A sintaxe <code>1~4p</code> diz ao <code>sed</code> que queremos come\u00e7ar na linha 1 e extrair de 4 em 4 linhas. Se o conte\u00fado do <code>ficheiro.txt</code> for:</p> <pre><code>Linha 1\nLinha 2\nLinha 3\nLinha 4\nLinha 5\nLinha 6\nLinha 7\nLinha 8\n</code></pre> <p>O comando produz o efeito: <pre><code>Linha 1\nLinha 5\n</code></pre></p>"},{"location":"lab04/intro/","title":"Processamento B\u00e1sico de Sequ\u00eancias","text":""},{"location":"lab04/intro/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li>Escreva uma fun\u00e7\u00e3o <code>random_dna_sequence</code> que crie uma sequ\u00eancia de DNA aleat\u00f3ria de tamanho <code>length</code>, com a mesma funcionalidade da Random DNA Sequence do SMS2. <pre><code>def random_dna_sequence(length):\n    ...\n</code></pre></li> <li>Escreva uma fun\u00e7\u00e3o <code>random_sequence</code> que altere a fun\u00e7\u00e3o anterior para tamb\u00e9m poder gerar sequ\u00eancias de RNA aleat\u00f3rias: <pre><code>def random_sequence(length, seq_type):\n    ...\n</code></pre></li> <li> <p>Incorpore tamb\u00e9m a possibilidade de criar sequ\u00eancias aleat\u00f3tias de prote\u00ednas, com a mesma funcionalidade da Random Protein Sequence do SMS2.</p> </li> <li> <p>Crie uma fun\u00e7\u00e3o <code>validate_dna</code> para verificar se a sequ\u00eancia de dna de input \u00e9 v\u00e1lida (retorna <code>True</code> se for v\u00e1lida e <code>False</code> caso contr\u00e1rio). <pre><code>def validate_dna(dna_seq):\n    ...\n</code></pre></p> </li> <li> <p>Generalize a fun\u00e7\u00e3o anterior (<code>validate_sequence</code>) para validar sequ\u00eancias de RNA e prote\u00ednas.</p> </li> <li> <p>Crie uma fun\u00e7\u00e3o <code>hamming_distance</code> que determine a dist\u00e2ncia de Hamming entre duas sequ\u00eancias. <pre><code>def hamming_distance(seq1, seq2):\n    ...\n</code></pre></p> </li> <li> <p>Crie uma fun\u00e7\u00e3o <code>dot_plot</code> que retorne uma matrix de compara\u00e7\u00e3o entre duas sequ\u00eancias: <pre><code>def dot_plot(seq1, seq2):\n    ...\n</code></pre></p> </li> <li>Crie uma fun\u00e7\u00e3o <code>count_nucleotides</code> que retorne o n\u00famero de nucle\u00f3tidos da sequ\u00eancia, para cada tipo (considere a constru\u00e7\u00e3o de um dicion\u00e1rio). <pre><code>def count_nucleotides(sequence):\n    ...\n</code></pre></li> <li>Crie uma fun\u00e7\u00e3o que determine a percentagem de nucle\u00f3tidos <code>C</code> e <code>G</code> na sequ\u00eancia. <pre><code>def gc_content(dna_seq):\n    ...\n</code></pre></li> <li>Escreva um fun\u00e7\u00e3o <code>transcript</code> que transcreva a sequ\u00eancia de DNA dada. <pre><code>def transcript(dna_seq):\n    ...\n</code></pre></li> <li>Crie uma fun\u00e7\u00e3o <code>reverse</code> que a partir de uma sequ\u00eancia de DNA gere o seu reverso. Compare o seu resultado com a fun\u00e7\u00e3o Reverse Complement do SMS2 (escolha a op\u00e7\u00e3o \"reverse\"). <pre><code>def reverse(dna_seq):\n    ...\n</code></pre></li> <li>Crie uma fun\u00e7\u00e3o <code>complement</code> que a partir de uma sequ\u00eancia de DNA gere o seu complemento. Compare o seu resultado com a fun\u00e7\u00e3o Reverse Complement do SMS2 (escolha a op\u00e7\u00e3o \"complement\"). <pre><code>def complement(dna_seq):\n    ...\n</code></pre></li> <li>Crie uma fun\u00e7\u00e3o <code>reverse_complement</code> que a partir de uma sequ\u00eancia de DNA gere o seu complemento reverso (use as fun\u00e7\u00f5es que acabou de criar!). Compare o seu resultado com a fun\u00e7\u00e3o Reverse Complement do SMS2 (escolha a op\u00e7\u00e3o \"reverse complement\"). <pre><code>def reverse_complement(dna_seq):\n    ...\n</code></pre></li> <li> <p>Escreva uma fun\u00e7\u00e3o <code>translate_seq</code> que traduza uma sequ\u00eancia de DNA para uma cadeia de amino\u00e1cidos. Use a seguinte fun\u00e7\u00e3o <code>translate_codon(codon)</code>: <pre><code>def translate_codon(codon):\n    \"\"\" Translates a codon into an aminoacid.\n        Considers the direct translation of DNA to proteins\n        using a provided conversion table.\n    \"\"\"\n    map = {\"GCT\":\"A\", \"GCC\":\"A\", \"GCA\":\"A\", \"GCG\":\"A\",\n           \"TGT\":\"C\", \"TGC\":\"C\", \"GAT\":\"D\", \"GAC\":\"D\",\n           \"GAA\":\"E\", \"GAG\":\"E\", \"TTT\":\"F\", \"TTC\":\"F\",\n           \"GGT\":\"G\", \"GGC\":\"G\", \"GGA\":\"G\", \"GGG\":\"G\",\n           \"CAT\":\"H\", \"CAC\":\"H\", \"ATA\":\"I\", \"ATT\":\"I\",\n           \"ATC\":\"I\", \"AAA\":\"K\", \"AAG\":\"K\", \"TTA\":\"L\",\n           \"TTG\":\"L\", \"CTT\":\"L\", \"CTC\":\"L\", \"CTA\":\"L\",\n           \"CTG\":\"L\",\"ATG\":\"M\", \"AAT\":\"N\", \"AAC\":\"N\", \n           \"CCT\":\"P\", \"CCC\":\"P\", \"CCA\":\"P\", \"CCG\":\"P\",\n           \"CAA\":\"Q\", \"CAG\":\"Q\", \"CGT\":\"R\", \"CGC\":\"R\",\n           \"CGA\":\"R\", \"CGG\":\"R\", \"AGA\":\"R\", \"AGG\":\"R\",\n           \"TCT\":\"S\", \"TCC\":\"S\", \"TCA\":\"S\", \"TCG\":\"S\",\n           \"AGT\":\"S\", \"AGC\":\"S\", \"ACT\":\"T\", \"ACC\":\"T\",\n           \"ACA\":\"T\", \"ACG\":\"T\", \"GTT\":\"V\", \"GTC\":\"V\",\n           \"GTA\":\"V\", \"GTG\":\"V\", \"TGG\":\"W\", \"TAT\":\"Y\",\n           \"TAC\":\"Y\",\"TAA\":\"_\", \"TAG\":\"_\", \"TGA\":\"_\"\n           }\n\n    if codon.upper() in map:\n        return map[codon]\n    return None\n</code></pre></p> </li> <li> <p>Escreva uma fun\u00e7\u00e3o codon_plot que receba uma sequ\u00eancia de DNA e gere um histograma com a contagem de cada cod\u00e3o. Compare o resultado obtido com o Codon Plot do SMS2. Pode epxlorar os m\u00f3dulos matplotlib ou seaborn para fazer gr\u00e1ficos mais detalhados.</p> </li> <li> <p>Estenda a fun\u00e7\u00e3o anterior para poder considerar a leitura noutras posi\u00e7\u00f5es, i.e., come\u00e7ando nas posi\u00e7\u00f5es 0, 1 e 2 para encontrar as 3 reading frames da sequ\u00eancia fornecida. <pre><code>def translate_dna_seq(dna_seq, init_pos):\n    ...\n</code></pre> Por exemplo: <pre><code>dna_seq='ATGGGGCTCAGCGAC'\nprint(translate_dna_seq(dna_seq)) # 'MGLSD'\nprint(translate_dna_seq(dna_seq, init_pos=1)) # 'WGSA'\nprint(translate_dna_seq(dna_seq, init_pos=2)) # 'GAQR'\n</code></pre></p> </li> <li> <p>Estenda a fun\u00e7\u00e3o anterior para que, dada uma sequ\u00eancia de DNA, sejam calculadas todas as reading frames poss\u00edveis (as 3 da conding strand e as 3 da template strand). Compare o resultado seguinte com o SMS2 Translate. Por exemplo, de acordo com o SMS2, a sequ\u00eancia: <pre><code>dna_seq = 'AATGCTCGTAATTTA'\n</code></pre> Deveria retornar: <pre><code>Reading Frame 1, Direct: NARNL\nReading Frame 2, Direct: MLVI\nReading Frame 3, Direct: CS*F\nReading Frame 1, Reverse: *ITSI\nReading Frame 2, Reverse: KLRA\nReading Frame 3, Reverse: NYEH\n</code></pre></p> </li> <li>Escreva uma fun\u00e7\u00e3o <code>read_genome</code> que leia um ficheiro <code>.fa</code> para que depois possam ser usadas as fun\u00e7\u00f5es previamente definidas. Por exemplo: <pre><code>fname = input(\"Insert input filename\")\nseq = read_genome(fname)\nif validate_dna(seq):\n    print(\"Valid sequence\")\n    print(\"Transcription: \", transcript(seq))\n    print(\"Reverse complement: \", reverse_complement(seq))\n    print(\"GC Content: \", gc_content(seq))\n    print(\"Translation: \", translate_seq(seq))\nelse: print(\"DNA Sequence is not valid\")\n</code></pre></li> </ol>"},{"location":"lab05/ex05_01/","title":"Exerc\u00edcio 1: <code>DNASequence</code>","text":"<p>As sequ\u00eancias de DNA s\u00e3o compostas pelos caracteres <code>A</code>, <code>T</code>, <code>C</code> e <code>G</code>. \u00c9 comum manipul\u00e1-las, revertendo a ordem, encontrando o seu complemento, calculando a percentagem de nucle\u00f3tidos GC ou gerando sequ\u00eancias aleat\u00f3rias. A programa\u00e7\u00e3o orientada a objetos permite encapsular essas funcionalidades dentro de uma classe <code>DNASequence</code>.</p>"},{"location":"lab05/ex05_01/#tarefa-1-criar-a-classe-dnasequence","title":"Tarefa 1: Criar a classe <code>DNASequence</code>","text":"<p>Implemente uma classe <code>DNASequence</code> com as seguintes funcionalidades:</p> <ol> <li>Um atributo de classe <code>ALPHABET = \"ATCG\"</code>.</li> <li>Um m\u00e9todo de classe <code>is_invalid(cls)</code> para verificar se uma sequ\u00eancia \u00e9 v\u00e1lida.</li> <li>Um construtor (<code>__init__</code>) que armazene <code>seq</code> caso a sequ\u00eancia introduzida seja v\u00e1lida.</li> <li>Um m\u00e9todo de classe <code>random_seq(cls, length)</code> para gerar uma sequ\u00eancia aleat\u00f3ria de DNA.</li> </ol>"},{"location":"lab05/ex05_01/#tarefa-2-implementar-metodos-especiais-dunder","title":"Tarefa 2: Implementar M\u00e9todos Especiais (Dunder)","text":"<ol> <li><code>__str__(self)</code> e <code>__repr__(self)</code> para efeitos de representa\u00e7\u00e3o</li> <li><code>__eq__(self, other)</code>: Retorna <code>True</code> se duas sequ\u00eancias forem iguais.</li> <li><code>__len__(self)</code>: Retorna o comprimento da sequ\u00eancia.</li> <li><code>__getitem__(self, index)</code>: Permite aceder a uma base por index.</li> <li><code>__add__(self, other)</code>: Retorna a concatena\u00e7\u00e3o de duas sequ\u00eancias. Nota, deve retornar uma nova <code>DNASequence</code>!</li> </ol>"},{"location":"lab05/ex05_01/#tarefa-3-outros-metodos","title":"Tarefa 3: Outros M\u00e9todos","text":"<ol> <li><code>nucleotide_frequency(self)</code>: Retorna um dicion\u00e1rio com a contagem de cada nucle\u00f3tido.</li> <li><code>reverse_complement(self)</code>: Retorna o complemento reverso da sequ\u00eancia de DNA.</li> <li><code>mutate_base(self, index, new_base)</code>: Modifica um nucle\u00f3tido numa posi\u00e7\u00e3o espec\u00edfica se for v\u00e1lido. Devolve uma nova <code>DNASequence</code></li> </ol>"},{"location":"lab05/ex05_02/","title":"Exerc\u00edcio 2: <code>RNASequence</code>","text":"<p>As sequ\u00eancias de RNA utilizam A, U, C e G em vez de A, T, C e G. O RNA \u00e9 traduzido em prote\u00ednas, onde cada cod\u00e3o (triplets de bases) \u00e9 convertido num amino\u00e1cido atrav\u00e9s do c\u00f3digo gen\u00e9tico.</p>"},{"location":"lab05/ex05_02/#tarefa-1-criar-a-classe-rnasequence","title":"Tarefa 1: Criar a classe <code>RNASequence</code>","text":"<p>Implemente uma classe <code>RNASequence</code> com:</p> <ol> <li>Um atributo de classe <code>ALPHABET = \"AUCG\"</code>.</li> <li>Um construtor (<code>__init__</code>) que verifique a validade da sequ\u00eancia, de forma semelhante \u00e0 classe <code>DNASequence</code>.</li> <li>Um m\u00e9todo de classe <code>codon_to_aa(cls, codon)</code> que traduz um cod\u00e3o no seu amino\u00e1cido respectivo. Pode usar o dicion\u00e1rio seguinte como um atributo de classe:</li> </ol> <pre><code>RNA_Codons = {\n    # 'M' - START, '_' - STOP\n    \"GCU\": \"A\", \"GCC\": \"A\", \"GCA\": \"A\", \"GCG\": \"A\",\n    \"UGU\": \"C\", \"UGC\": \"C\",\n    \"GAU\": \"D\", \"GAC\": \"D\",\n    \"GAA\": \"E\", \"GAG\": \"E\",\n    \"UUU\": \"F\", \"UUC\": \"F\",\n    \"GGU\": \"G\", \"GGC\": \"G\", \"GGA\": \"G\", \"GGG\": \"G\",\n    \"CAU\": \"H\", \"CAC\": \"H\",\n    \"AUA\": \"I\", \"AUU\": \"I\", \"AUC\": \"I\",\n    \"AAA\": \"K\", \"AAG\": \"K\",\n    \"UUA\": \"L\", \"UUG\": \"L\", \"CUU\": \"L\", \"CUC\": \"L\", \"CUA\": \"L\", \"CUG\": \"L\",\n    \"AUG\": \"M\",\n    \"AAU\": \"N\", \"AAC\": \"N\",\n    \"CCU\": \"P\", \"CCC\": \"P\", \"CCA\": \"P\", \"CCG\": \"P\",\n    \"CAA\": \"Q\", \"CAG\": \"Q\",\n    \"CGU\": \"R\", \"CGC\": \"R\", \"CGA\": \"R\", \"CGG\": \"R\", \"AGA\": \"R\", \"AGG\": \"R\",\n    \"UCU\": \"S\", \"UCC\": \"S\", \"UCA\": \"S\", \"UCG\": \"S\", \"AGU\": \"S\", \"AGC\": \"S\",\n    \"ACU\": \"T\", \"ACC\": \"T\", \"ACA\": \"T\", \"ACG\": \"T\",\n    \"GUU\": \"V\", \"GUC\": \"V\", \"GUA\": \"V\", \"GUG\": \"V\",\n    \"UGG\": \"W\",\n    \"UAU\": \"Y\", \"UAC\": \"Y\",\n    \"UAA\": \"_\", \"UAG\": \"_\", \"UGA\": \"_\"\n}\n</code></pre>"},{"location":"lab05/ex05_02/#tarefa-2-outros-metodos","title":"Tarefa 2: Outros M\u00e9todos","text":"<ol> <li><code>translate_seq(self, frame=0)</code>: Converte a sequ\u00eancia de RNA numa prote\u00edna, come\u00e7ando numa determinada <code>frame</code> (reading frame).</li> <li>Acrescente \u00e0 classe <code>DNASequence</code> um m\u00e9todo <code>transcribe(self)</code> que transforme uma sequ\u00eancia de DNA numa sequ\u00eancia de RNA. Neste caso, o m\u00e9todo deve retornar uma <code>RNASequence</code>.</li> <li>Acrescente \u00e0 classe <code>DNASequence</code> tamb\u00e9m um m\u00e9todo <code>translate_seq(self, frame=0)</code> que converte a sequ\u00eancia de DNA numa prote\u00edna, come\u00e7ando numa determinada <code>frame</code> (reading frame). O m\u00e9todo deve tamb\u00e9m devolver uma <code>RNASequence</code>. Pode usar o dicion\u00e1rio seguinte como um atributo de classe (na classe <code>DNASequence</code>!):</li> </ol> <pre><code>DNA_Codons = {\n    # 'M' - START, '_' - STOP\n    \"GCT\": \"A\", \"GCC\": \"A\", \"GCA\": \"A\", \"GCG\": \"A\",\n    \"TGT\": \"C\", \"TGC\": \"C\",\n    \"GAT\": \"D\", \"GAC\": \"D\",\n    \"GAA\": \"E\", \"GAG\": \"E\",\n    \"TTT\": \"F\", \"TTC\": \"F\",\n    \"GGT\": \"G\", \"GGC\": \"G\", \"GGA\": \"G\", \"GGG\": \"G\",\n    \"CAT\": \"H\", \"CAC\": \"H\",\n    \"ATA\": \"I\", \"ATT\": \"I\", \"ATC\": \"I\",\n    \"AAA\": \"K\", \"AAG\": \"K\",\n    \"TTA\": \"L\", \"TTG\": \"L\", \"CTT\": \"L\", \"CTC\": \"L\", \"CTA\": \"L\", \"CTG\": \"L\",\n    \"ATG\": \"M\",\n    \"AAT\": \"N\", \"AAC\": \"N\",\n    \"CCT\": \"P\", \"CCC\": \"P\", \"CCA\": \"P\", \"CCG\": \"P\",\n    \"CAA\": \"Q\", \"CAG\": \"Q\",\n    \"CGT\": \"R\", \"CGC\": \"R\", \"CGA\": \"R\", \"CGG\": \"R\", \"AGA\": \"R\", \"AGG\": \"R\",\n    \"TCT\": \"S\", \"TCC\": \"S\", \"TCA\": \"S\", \"TCG\": \"S\", \"AGT\": \"S\", \"AGC\": \"S\",\n    \"ACT\": \"T\", \"ACC\": \"T\", \"ACA\": \"T\", \"ACG\": \"T\",\n    \"GTT\": \"V\", \"GTC\": \"V\", \"GTA\": \"V\", \"GTG\": \"V\",\n    \"TGG\": \"W\",\n    \"TAT\": \"Y\", \"TAC\": \"Y\",\n    \"TAA\": \"_\", \"TAG\": \"_\", \"TGA\": \"_\"\n}\n</code></pre>"},{"location":"lab05/ex05_03/","title":"Exerc\u00edcio 3: <code>BaseSequence</code>","text":"<p>As classes <code>DNASequence</code> e o <code>RNASequence</code> partilham diversas funcionalidades. Para evitar redund\u00e2ncia, podemos criar uma <code>BaseSequence</code> para armazenar as funcionalidades comuns e ser herdada por ambas as classes.</p>"},{"location":"lab05/ex05_03/#tarefa-1-criar-a-class-basesequence","title":"Tarefa 1: Criar a class <code>BaseSequence</code>","text":"<ol> <li>Identifique os atributos e m\u00e9todos comuns (<code>__len__</code>, <code>__repr__</code>, <code>is_invalid</code>, etc.) e mova-os para a <code>BaseSequence</code>.</li> <li>Modifique a <code>DNASequence</code> e a <code>RNASequence</code> para herdarem de <code>BaseSequence</code>.</li> <li>Adicione um m\u00e9todo <code>gc_content(self)</code> em <code>BaseSequence</code> para poder ser usado pela <code>DNASequence</code> e a <code>RNASequence</code>.</li> <li>Que m\u00e9todos permanecem apenas na <code>DNASequence</code> ou na <code>RNASequence</code>? Porqu\u00ea? </li> </ol>"},{"location":"lab05/ex05_04/","title":"Exerc\u00edcio 4: <code>BioSequence</code> e <code>ProteinSequence</code>","text":"<p>As sequ\u00eancias de DNA e RNA diferem fundamentalmente das sequ\u00eancias de prote\u00ednas, apesar de terem alguns elementos semelhantes. Enquanto os nucle\u00f3tidos (A, T, C, G, U) formam as sequ\u00eancias b\u00e1sicas, as prote\u00ednas s\u00e3o compostas por amino\u00e1cidos. Precisamos ajustar a estrutura das classes para acomodar essa diferen\u00e7a.</p>"},{"location":"lab05/ex05_04/#tarefa-1-code-refactoring-com-biosequence","title":"Tarefa 1: Code Refactoring com <code>BioSequence</code>","text":"<ol> <li>Crie uma nova class <code>BioSequence</code>.</li> <li>Modifique a <code>BaseSequence</code> para herdar de <code>BioSequence</code>.</li> <li>Crie uma nova classe, <code>ProteinSequence</code>, que herda de <code>BioSequence</code>. O alfabeto de prote\u00ednas dever\u00e1 ser <code>ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"</code></li> <li>A inicializa\u00e7\u00e3o e valida\u00e7\u00e3o das sequ\u00eancias deve ser movida para a classe <code>BioSequence</code>.</li> <li>O m\u00e9todo <code>gc_content</code> deve permanecer em <code>BaseSequence</code> porque s\u00f3 \u00e9 aplicado a DNA e RNA, n\u00e3o prote\u00ednas.</li> </ol>"},{"location":"lab05/ex05_04/#tarefa-2-implementar-metodos-especificos-das-proteinas","title":"Tarefa 2: Implementar M\u00e9todos Espec\u00edficos das Prote\u00ednas","text":"<p>Implemente o m\u00e9todo <code>longest_non_stop(?)</code> que receba uma sequ\u00eancia de DNA ou RNA como par\u00e2metro e devolva a maior sequ\u00eancia de de amino\u00e1cidos que pode ser produzida atrav\u00e9s dela. Na pr\u00e1tica, \u00e9 necess\u00e1rio geral as 6 poss\u00edveis reading frames a partir da sequ\u00eancia, convert\u00ea-las para sequ\u00eancias de amino\u00e1cidos (ou seja, usar os m\u00e9todos <code>translate_seq</code>) e depois \"partir\" as sequ\u00eancias nos cod\u00f5es STOP, caso exista algum. </p> <p>Por exemplo, na sequ\u00eancia de DNA <code>AGCTACTAGGAAGATAGACGATTAGAC</code>, as 6 cadeias de amino\u00e1cidos que se podem formar s\u00e3o:</p> <ul> <li><code>SY*EDRRLD</code> (Frame 1)</li> <li><code>ATRKIDD*</code> (Frame 2)</li> <li><code>LLGR*TIR</code> (Frame 3)</li> <li><code>V*SSIFLVA</code> (Frame 4)</li> <li><code>SNRLSS**</code> (Frame 5)</li> <li><code>LIVYLPSS</code> (Frame 6)</li> </ul> <p>Por ordem de tamanho teremos: <code>V</code>, <code>SY</code>, <code>LLGR</code>, <code>SNRLSS</code>, <code>ATRKIDD</code>, and <code>LIVYLPSS</code>. Deste mode, o m\u00e9todo <code>longest_non_stop(self)</code> deveria retornar <code>LIVYLPSS</code>. Fa\u00e7as as modifica\u00e7\u00f5es que entender necess\u00e1rias \u00e0s classes anteriores.</p>"},{"location":"lab05/intro/","title":"Workflows para Processamento de Sequ\u00eancias Biol\u00f3gicas","text":"<p>Neste laborat\u00f3rio, iremos dedicar-nos \u00e0 re-implementa\u00e7\u00e3o das fun\u00e7\u00f5es do laborat\u00f3rio anterior num paradigma orientado a objectos. </p> <p>Os exerc\u00edcios desta semana pretendem que as/os estudantes possam:</p> <ul> <li>Aprender a modelar sequ\u00eancias biol\u00f3gicas utilizando classes.</li> <li>Compreender m\u00e9todos especiais (dunder methods) como <code>__eq__</code>, <code>__repr__</code>, <code>__len__</code>.</li> <li>Implementar m\u00e9todos est\u00e1ticos e de classe de forma eficaz (<code>@staticmethods</code> e <code>@classmethods</code>).</li> <li>Utilizar heran\u00e7a para organizar e reutilizar c\u00f3digo.</li> <li>Planear e implementar workflows bioinform\u00e1ticos utilizando Programa\u00e7\u00e3o Orientada a Objectos.</li> </ul>"},{"location":"lab05/intro/#exercicios","title":"Exerc\u00edcios","text":"<ul> <li>Exerc\u00edcio 1: <code>DNASequence</code></li> <li>Exerc\u00edcio 2: <code>RNASequence</code></li> <li>Exerc\u00edcio 3: <code>BaseSequence</code></li> <li>Exerc\u00edcio 4: <code>BioSequence</code> e <code>ProteinSequence</code></li> </ul> <p>Para apoiar a resolu\u00e7\u00e3o dos exerc\u00edcios, poder\u00e1 consultar:</p> <ul> <li>Shawn T. O\u2019Neil, A Primer for Computational Biology</li> <li>Mitchell L. Model, Bioinformatics Programming Using Python</li> </ul>"}]}